#!/bin/sh



# constants for tor bandwidth monitoring rules

backup_script_dir="/tmp/bw_backup"
backup_script="$backup_dir/do_tor_bw_backup.sh"

minute_s=60
hour_s=3600
day_s=86400

#high res intervals
hr1_interval=2
hr1_num_intervals=449
hr1_reset_time=2
	
hr2_interval="minute"
hr2_num_intervals=359
	
hr3_interval=$((3*$minute_s))
hr3_num_intervals=479
hr3_reset_time=$((3*$minute_s))
	
hr4_interval=$((2*$hour_s))
hr4_num_intervals=359
hr4_reset_time=$((2*$hour_s))

hr5_interval="day"
hr5_num_intervals=365

#low res intervals
lr1_interval="minute"
lr1_num_intervals=15

lr2_interval=$((15*$minute_s))
lr2_num_intervals=24
lr2_reset_time=$((15*$minute_s))
	
lr3_interval="hour"
lr3_num_intervals=24

lr4_interval="day"
lr4_num_intervals=31

lr5_interval="month"
lr5_num_intervals=12


mon_nums="1 2 3 4 5"
bw_ids=""



bw_restore()
{
	bw_id="$1"
	backup_to_tmp="$2"
	
	if [ -e "/usr/data/bwmon/$bw_id.bw" ] ; then
		bw_set -i "$bw_id" -h -f /usr/data/bwmon/$bw_id.bw >/dev/null 2>&1
	elif [ -e "/tmp/data/bwmon/$bw_id.bw" ] ; then
		bw_set -i "$bw_id" -h -f /tmp/data/bwmon/$bw_id.bw >/dev/null 2>&1
	elif [ -e "/usr/data/bwmon/$bw_id" ] ; then
		bw_convert "/usr/data/bwmon/$bw_id" "/usr/data/bwmon/$bw_id.bw"
		rm "/usr/data/bwmon/$bw_id"
		bw_set -i "$bw_id" -h -f /usr/data/bwmon/$bw_id.bw >/dev/null 2>&1
	elif [ -e "/tmp/data/bwmon/$bw_id" ] ; then
		bw_convert "/tmp/data/bwmon/$bw_id" "/usr/data/bwmon/$bw_id.bw"
		rm "/tmp/data/bwmon/$bw_id"
		bw_set -i "$bw_id" -h -f /tmp/data/bwmon/$bw_id.bw >/dev/null 2>&1
	fi

	if [ -e "$tmp_cron" ] ; then
		if [ "$backup_to_tmp" = "1" ] ; then
			echo "bw_get -i \"$bw_id\" -h -f \"/tmp/data/bwmon/$bw_id.bw\" >/dev/null 2>&1" >> "$backup_script"
		else
			echo "bw_get -i \"$bw_id\" -h -f \"/usr/data/bwmon/$bw_id.bw\" >/dev/null 2>&1" >> "$backup_script"
		fi
	fi
}

update_cron()
{
	old_md5=$(md5sum /etc/crontabs/root)
	old_md5=${old_md5% *}
	new_md5=$(md5sum "$tmp_cron")
	new_md5=${new_md5% *}
	if [ "$old_md5" = "$new_md5" ] ; then
		rm "$tmp_cron"
	else
		mv "$tmp_cron" /etc/crontabs/root
		if pidof crond > /dev/null 2>&1; then
			/etc/init.d/cron restart
		fi
	fi
}


clear_chains()
{
	delete_chain_from_table nat    tor_client
	delete_chain_from_table filter tor_client
	delete_chain_from_table filter tor_relay
	
	delete_chain_from_table filter tor_client_down_bw
	delete_chain_from_table mangle tor_client_up_bw
	
	delete_chain_from_table filter tor_relay_down_bw
	delete_chain_from_table mangle tor_relay_up_bw

}

initialize()
{

	enabled=$( uci get tor.global.enabled 2>/dev/null )
	client_mode=$( uci get tor.client.client_mode 2>/dev/null )
	relay_mode=$( uci get tor.relay.relay_mode 2>/dev/null )
	if [ -z "$enabled" ] ; then
		enabled = "0"
	fi
	
	if [ "$enabled" != "0" ] && [ "$client_mode" != "0" ] ; then
		
	
		enabled_ip_file=$( uci get tor.client.enabled_ip_file 2>/dev/null)
		dns_port=$( uci get tor.client.dns_port 2>/dev/null )
		trans_port=$( uci get tor.client.trans_port 2>/dev/null )
		zone=$( uci get tor.client.zone 2>/dev/null )
		block_unsupported_proto=$( uci get tor.client.block_unsupported_proto 2>/dev/null )
		if [ -z "$zone" ] ; then 
			zone="lan"
		fi
		zone_ip=$(uci -P /var/state get network.$zone.ipaddr 2>/dev/null )
		zone_mask=$(uci -P /var/state get network.$zone.netmask 2>/dev/null )
		
		hidden_service_subnet=$( uci get tor.client.hidden_service_subnet 2>/dev/null )
		hidden_service_mask_bits=$( uci get tor.client.hidden_service_mask_bits 2>/dev/null )
		if [ -z "$hidden_service_subnet" ] || [ -z "$hidden_service_mask_bits" ] ; then
			hidden_service_subnet="10.192.0.0"
			hidden_service_mask_bits="12"
			uci set tor.client.hidden_service_subnet="$hidden_service_subnet"
			uci set tor.client.hidden_service_mask_bits="$hidden_service_mask_bits"
			uci commit
		fi
	
	
		# setup client mode firewall rules
		iptables -t nat    -N tor_client
		iptables -t filter -N tor_client
	
		if [ "$client_mode" = "2" ] ; then
		
			if [ -n "$enabled_ip_file" ] ; then
				touch "$enabled_ip_file" 
			fi
		
			ipset --destroy tor_active_ips >/dev/null 2>&1
			ipset --create  tor_active_ips iphash
			for ip in $(cat $enabled_ip_file) ; do ipset --add tor_active_ips $ip ; done
		fi
	
	
	
		if [ "$client_mode" = "3" ] ; then
			iptables -t nat -A tor_client -p udp --dport 53 -m layer7 --l7proto oniondns -j REDIRECT --to-ports $dns_port
			iptables -t nat -A tor_client -p tcp --dport 53 -m layer7 --l7proto oniondns -j REDIRECT --to-ports $dns_port
			iptables -t nat -A tor_client -p tcp ! --dport 53 -d $hidden_service_subnet/$hidden_service_mask_bits  -j REDIRECT --to-ports $trans_port 
	
		else
		
			# dns rules
			iptables -t nat -A tor_client -p udp   --dport 53 -j REDIRECT --to-ports $dns_port
			iptables -t nat -A tor_client -p tcp   --dport 53 -j REDIRECT --to-ports $dns_port
		
			# don't redirect local addresses
			if [ -n "$zone_ip" ] && [ -n "$zone_mask" ] ; then
				iptables -t nat    -A tor_client -d $zone_ip/$zone_mask -j RETURN
				iptables -t filter -A tor_client -d $zone_ip/$zone_mask -j RETURN
			elif [ -n "$zone_ip" ] ; then
				iptables -t nat    -A tor_client -d $zone_ip -j RETURN
				iptables -t filter -A tor_client -d $zone_ip -j RETURN
			fi
			
			# redirect to tor transparent proxy
			iptables -t nat -A tor_client -p tcp ! --dport 53 -j REDIRECT --to-ports $trans_port 
		
			# jump to tor_client chain at start of zone prerouting chain if enabled for this IP
			test_tor_active=""
			if  [ "$client_mode" = "2" ] ; then
				test_tor_active=" -m set --match-set tor_active_ips src "
			fi
		
			if [ "$block_unsupported_proto" = "1" ] ; then
				iptables -t filter -A tor_client -p tcp ! --dport 53 -j RETURN 
				iptables -t filter -A tor_client -p udp   --dport 53 -j RETURN
				iptables -t filter -A tor_client -j REJECT
				iptables -t filter -I zone_${zone}_forward $test_tor_active -j tor_client
			fi
		fi
		iptables -t nat -I zone_${zone}_prerouting $test_tor_active -j tor_client
	
	
		#monitor client bandwidth
		wan_if=$(uci -P /var/state get network.wan.ifname 2>/dev/null)
		if [ -z "$relay_if" ] ; then
			wan_if=$(uci -P /var/state get network.wan.device 2>/dev/null)
		fi
		if [ -n "$wan_if" ] ; then
			for n in $mon_nums ; do
				
				for res in "hr" "lr" ; do
					interval=$(eval "echo \$$res"$n"_interval")
					num_intervals=$(eval "echo \$$res"$n"_num_intervals")
					reset_time=$(eval "echo \$$res"$n"_reset_time")
					if [ -n "$reset_time" ] ; then reset_time="--reset_time $reset_time" ; fi
	
					iptables -t filter -A tor_relay_down_bw  -m bandwidth --id "tor-client-$res$n-download-$interval-$num_intervals" --reset_interval $interval --intervals_to_save $num_intervals $reset_time
					iptables -t mangle -A tor_relay_up_bw    -m bandwidth --id "tor-client-$res$n-upload-$interval-$num_intervals" --reset_interval $interval --intervals_to_save $num_intervals $reset_time
					
					next_ids="tor-client-$res$n-download-$interval-$num_intervals tor-client-$res$n-upload-$interval-$num_intervals"
					if [ -z "$bw_ids" ] ; then bw_ids="$next_ids" else bw_ids="$bw_ids $next_ids" fi
				done
		
				
				for p in $trans_port $dns_port ; do
					iptables -t filter -I INPUT        -i $relay_if -p tcp --dport $p -j tor_relay_down_bw
					iptables -t filter -I FORWARD      -i $relay_if -p tcp --dport $p -j tor_relay_down_bw
					iptables -t mangle -A POSTROUTING  -o $relay_if -p tcp --sport $p -j tor_relay_up_bw
				done
				
			
			done
		
		fi
	
	fi
	
	
	
	
	if [ "$enabled" != "0"  && "$relay_mode" != "0" ] ; then
		relay_zone=$(uci get tor.relay.zone)
		relay_port=$(uci get tor.relay.relay_port)
		obfsproxy_port=$(uci get tor.relay.obfsproxy_port)
	
		iptables -t filter -N tor_relay
		iptables -t filter -I tor_relay -p tcp --dport $relay_port -j ACCEPT
		if [ "$relay_mode" = "1" ] && [ -n "$obfsproxy_port" ] && [ "$obfsproxy_port" != "0" ] ; then
			iptables -t filter -I tor_relay -p tcp --dport $obfsproxy_port -j ACCEPT
		fi
		iptables -t filter -I input_${relay_zone} -j tor_relay
	
	
		iptables -t filter -N tor_relay_down_bw
		iptables -t mangle -N tor_relay_up_bw
	
		reset_interval=$((60*15))
		num_intervals=$((24*15))
		
		wait_sec=5
		while [ -z "$(uci -P /var/state get network.$relay_zone.up 2>/dev/null)" ] && [ "$wait_sec" -gt 0 ] ; do
			sleep 1
			wait_sec=$(($wait_sec - 1))
		done
	
	
		# monitor relay bandwidth
		relay_if=$(uci -P /var/state get network.$relay_zone.ifname 2>/dev/null)
		if [ -z "$relay_if" ] ; then
			relay_if=$(uci -P /var/state get network.$relay_zone.device 2>/dev/null)
		fi
		
		if [ -n "$relay_if" ] ; then
	
			for n in $mon_nums ; do
				for res in "hr" "lr" ; do
					interval=$(eval "echo \$$res"$n"_interval")
					num_intervals=$(eval "echo \$$res"$n"_num_intervals")
					reset_time=$(eval "echo \$$res"$n"_reset_time")
					if [ -n "$reset_time" ] ; then reset_time="--reset_time $reset_time" ; fi
	
					iptables -t filter -A tor_relay_down_bw  -m bandwidth --id "tor-relay-$res$n-download-$interval-$num_intervals" --reset_interval $interval --intervals_to_save $num_intervals $reset_time
					iptables -t mangle -A tor_relay_up_bw    -m bandwidth --id "tor-relay-$res$n-upload-$interval-$num_intervals" --reset_interval $interval --intervals_to_save $num_intervals $reset_time
					
					next_ids="tor-relay-$res$n-download-$interval-$num_intervals tor-relay-$res$n-upload-$interval-$num_intervals"
					if [ -z "$bw_ids" ] ; then bw_ids="$next_ids" else bw_ids="$bw_ids $next_ids" fi
				done
	
			done
	
			oport=""
			if [ "$relay_mode" = "1" ] && [ -n "$obfsproxy_port" ] && [ "$obfsproxy_port" != "0" ] ; then oport="$obfsproxy_port" ; fi
			for p in $relay_port $oport ; do
				iptables -t filter -I INPUT        -i $relay_if -p tcp --dport $p -j tor_relay_down_bw
				iptables -t filter -I FORWARD      -i $relay_if -p tcp --dport $p -j tor_relay_down_bw
				iptables -t mangle -A POSTROUTING  -o $relay_if -p tcp --sport $p -j tor_relay_up_bw
			done
	
		fi
	fi
	
	
	if [ -n "$bw_ids" ] ; then
		touch /etc/crontabs/root
		grep -v "$backup_script" /etc/crontabs/root > "$tmp_cron"
		echo "0 0,4,8,12,16,20 * * * $backup_script" >> "$tmp_cron"
		
		mkdir -p "$backup_dir"
		echo "#!/bin/sh" > "$backup_script"
		chmod 700 "$backup_script"
		
	
		for i in $ids ; do
			is_total123=$(echo "$i" | egrep "total[123]")
			is_bdist123=$(echo "$i" | egrep "bdist[0123]")
			is_qos123=$(echo "$i" | egrep "qos[0123]")
			if [ -n "$is_total123" ] || [ -n "$is_bdist123" ] || [ -n "$is_qos123" ]  ; then
				bw_restore "$i" 1
			else
				bw_restore "$i" 0
			fi
		done
	
		update_cron 
	fi
}

shutdown()
{
	touch /etc/crontabs/root

	if [ -e "$backup_script" ] ; then
		sh "$backup_script" 2>/dev/null
		rm -rf "$backup_script"
	fi

	grep -v "$backup_script" /etc/crontabs/root > "$tmp_cron"
	update_cron

	clear_chains
}


shutdown
initialize


