--- haserl-0.9.26/src/Makefile.am	2009-04-27 14:32:14.000000000 -0400
+++ haserl-0.9.26/src/Makefile.am 2	2013-06-02 15:34:46.000000000 -0400
@@ -46,7 +46,7 @@
 
 haserl_SOURCES = common.c common.h sliding_buffer.c sliding_buffer.h \
 		 h_error.c h_error.h h_script.c h_script.h rfc2388.c rfc2388.h \
-		 $(BASHSOURCE) $(LUASOURCE) haserl.c haserl.h
+		 $(BASHSOURCE) $(LUASOURCE) h_translate.c h_translate.h haserl.c haserl.h
 
 install-strip:
         $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
--- haserl-0.9.26 SRC/src/Makefile.in	2009-07-30 19:14:06.000000000 -0400
+++ haserl-0.9.26/src/Makefile.in 2	2013-06-05 21:06:01.000000000 -0400
@@ -50,7 +50,7 @@
 	sliding_buffer.h h_error.c h_error.h h_script.c h_script.h \
 	rfc2388.c rfc2388.h h_bash.c h_bash.h haserl_lualib.inc \
 	h_lua_common.c h_lua_common.h h_lua.c h_lua.h h_luac.c \
-	h_luac.h haserl.c haserl.h
+	h_luac.h h_translate.c h_translate.h haserl.c haserl.h
 @INCLUDE_BASHSHELL_TRUE@am__objects_1 = h_bash.$(OBJEXT)
 @INCLUDE_LUASHELL_TRUE@@USE_LUA_TRUE@am__objects_2 = h_lua.$(OBJEXT)
 @INCLUDE_LUACSHELL_TRUE@@USE_LUA_TRUE@am__objects_3 =  \
@@ -59,7 +59,7 @@
 @USE_LUA_TRUE@	$(am__objects_3)
 am_haserl_OBJECTS = common.$(OBJEXT) sliding_buffer.$(OBJEXT) \
 	h_error.$(OBJEXT) h_script.$(OBJEXT) rfc2388.$(OBJEXT) \
-	$(am__objects_1) $(am__objects_4) haserl.$(OBJEXT)
+	$(am__objects_1) $(am__objects_4) h_translate.$(OBJEXT) haserl.$(OBJEXT)
 haserl_OBJECTS = $(am_haserl_OBJECTS)
 haserl_LDADD = $(LDADD)
 DEFAULT_INCLUDES = -I.@am__isrc@
@@ -99,7 +99,7 @@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
-LDFLAGS = @LDFLAGS@
+LDFLAGS = -luci -lericstools
 LIBOBJS = @LIBOBJS@
 LIBS = @LIBS@
 LN_S = @LN_S@
@@ -167,7 +167,7 @@
 @INCLUDE_BASHSHELL_TRUE@BASHSOURCE = h_bash.c h_bash.h
 haserl_SOURCES = common.c common.h sliding_buffer.c sliding_buffer.h \
 		 h_error.c h_error.h h_script.c h_script.h rfc2388.c rfc2388.h \
-		 $(BASHSOURCE) $(LUASOURCE) haserl.c haserl.h
+		 $(BASHSOURCE) $(LUASOURCE) h_translate.c h_translate.h haserl.c haserl.h
 
 all: config.h
 	$(MAKE) $(AM_MAKEFLAGS) all-am
@@ -260,6 +260,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/h_lua_common.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/h_luac.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/h_script.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/h_translate.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/haserl.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rfc2388.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sliding_buffer.Po@am__quote@
--- haserl-0.9.26 SRC/src/h_bash.c	2009-04-27 14:32:14.000000000 -0400
+++ haserl-0.9.26/src/h_bash.c	2013-06-05 22:01:30.000000000 -0400
@@ -38,6 +38,7 @@
 #endif
 
 #include "common.h"
+#include <erics_tools.h>
 #include "h_error.h"
 #include "h_bash.h"
 #include "h_script.h"
--- haserl-0.9.26 SRC/src/rfc2388.c	2009-04-27 14:35:27.000000000 -0400
+++ haserl-0.9.26/src/rfc2388.c	2013-06-05 22:02:14.000000000 -0400
@@ -37,6 +37,7 @@
 #endif
 
 #include "common.h"
+#include <erics_tools.h>
 #include "h_error.h"
 #include "h_script.h"
 #include "h_bash.h"
--- haserl-0.9.26 SRC/src/h_error.c	2009-04-27 14:32:14.000000000 -0400
+++ haserl-0.9.26/src/h_error.c	2013-06-05 22:05:16.000000000 -0400
@@ -31,6 +31,7 @@
 #include <stdarg.h>
 
 #include "common.h"
+#include <erics_tools.h>
 #include "h_script.h"
 #include "haserl.h"
 #include "h_error.h"
--- haserl-0.9.26/src/h_script.h	2009-04-27 14:32:14.000000000 -0400
+++ haserl-0.9.26/src/h_script.h	2013-06-02 15:38:18.000000000 -0400
@@ -20,7 +20,7 @@
 #ifdef BASHEXTENSIONS
 enum tag_t { HTML, RUN, INCLUDE, EVAL, COMMENT, IF, ELIF, ELSE, ENDIF, CASE, WHEN, OTHERWISE, ENDCASE, WHILE, ENDWHILE, UNTIL, ENDUNTIL, FOR, ENDFOR, UNLESS, ELUN, UNELSE, ENDUNLESS, NOOP };
 #else
-enum tag_t { HTML, RUN, INCLUDE, EVAL, COMMENT, NOOP };
+enum tag_t { HTML, RUN, INCLUDE, EVAL, COMMENT, TRANSLATE, NOOP };
 #endif
 
 
--- haserl-0.9.26 SRC/src/h_script.c	2009-04-27 14:35:03.000000000 -0400
+++ haserl-0.9.26/src/h_script.c	2013-06-06 01:17:20.000000000 -0400
@@ -32,8 +32,10 @@
 #include <ctype.h>
 
 #include "common.h"
+#include <erics_tools.h>
 #include "h_error.h"
 #include "h_script.h"
+#include "h_translate.h"
 #include "h_bash.h"
 #include "haserl.h"
 
@@ -42,7 +44,7 @@
    OTHERWISE, ENDCASE, WHILE, ENDWHILE, UNTIL, ENDUNTIL, FOR, ENDFOR,
    UNLESS, ELUN, UNELSE, ENDUNLESS, NOOP }; */
 #else
-/* HTML, RUN, INCLUDE, EVAL, COMMENT, NOOP */
+/* HTML, RUN, INCLUDE, EVAL, COMMENT, TRANSLATE, NOOP */
 #endif
 
 const char *g_tag[] = {
@@ -51,6 +53,7 @@
   "in",
   "=",
   "#",
+  "~"
 #ifdef BASHEXTENSIONS
   "if",
   "elif",
@@ -373,6 +376,15 @@
 	      me->buf = find_whitespace (me->buf);
 	      me->len = strlen (me->buf);
 	    }
+      else if (memcmp (cp, g_tag[TRANSLATE], 1) == 0)
+      {
+	      me->tag = TRANSLATE;
+	      me->buf = find_whitespace (me->buf);
+	      me->len = strlen (me->buf);
+         if (global.translationKV_map == NULL) {
+              buildTranslationMap ();
+	      }
+      }
 #ifdef BASHEXTENSIONS
 	  else if (memcmp (cp, g_tag[IF], 2) == 0)
 	    {
@@ -545,6 +557,9 @@
 	case EVAL:
 	  shell_eval (buf, token->buf, token->len);
 	  break;
+	case TRANSLATE:
+	  lookup_key (buf, token->buf);
+	  break;
 #ifdef BASHEXTENSIONS
 	case IF:
 	  shell_if (buf, token->buf, token->len);
--- haserl-0.9.26 SRC/src/haserl.h	2009-04-27 14:32:14.000000000 -0400
+++ haserl-0.9.26/src/haserl.h	2013-06-05 21:17:41.000000000 -0400
@@ -19,6 +19,11 @@
   int acceptall;                /* true if we'll accept POST data on 
   					GETs and vice versa 		     */
   int silent;                   /* true if we never print errors             */
+    
+  char *webroot;                /* return value for uci get gargoyle.global.web_root */
+  char *fallback_lang;          /* return value for uci get gargoyle.global.fallback_lang */
+  char *active_lang;            /* return value for uci get gargoyle.global.language */
+  string_map* translationKV_map; /* a map of js_page.elementKey = "A Localized String Value" */
 } haserl_t;
 
 extern haserl_t global;
--- haserl-0.9.26 SRC/src/haserl.c	2009-07-30 19:06:22.000000000 -0400
+++ haserl-0.9.26/src/haserl.c	2013-06-05 21:55:13.000000000 -0400
@@ -51,6 +51,7 @@
 #endif
 
 #include "common.h"
+#include <erics_tools.h>
 #include "h_error.h"
 #include "h_script.h"
 #include "sliding_buffer.h"
@@ -58,6 +59,7 @@
 #ifdef INCLUDE_BASHSHELL
 #include "h_bash.h"
 #endif
+#include "h_translate.h"
 
 #ifdef USE_LUA
 #include <lua.h>
@@ -645,7 +647,13 @@
   global.post_prefix = "POST_";
   global.cookie_prefix = "COOKIE_";
   global.nul_prefix = "";
+  // translationKV_map gets filled only if a <%~ translation %> tag is found; and unknowable until preprocessing
 
+  uci_init();
+
+  global.webroot=uci_get("gargoyle", "global", "web_root");
+  global.fallback_lang=uci_get("gargoyle", "global", "fallback_lang");
+  global.active_lang=uci_get("gargoyle", "global", "language");
 }
 
 
@@ -897,7 +905,9 @@
 #endif
       shell_destroy ();
     }
-
+    //printf("%s\n", global.webroot);
+    //printf("%s\n", global.fallback_lang);
+    //printf("%s\n", global.active_lang);
 
   if (global.uploadlist)
     {
--- /dev/null	2013-06-02 22:59:24.000000000 -0400
+++ haserl-0.9.26/src/h_translate.h	2013-06-02 21:05:08.000000000 -0400
@@ -0,0 +1,30 @@
+/* --------------------------------------------------------------------------
+ * Copyright 2013 BashfulBladder (bashfulbladder@gmail.com)
+ * 
+ *   This file is patch to haserl to provide i18n translation for Gargoyle
+ *   router firmware.
+ *
+ *   This file is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License version 2,
+ *   as published by the Free Software Foundation.
+ *
+ *   This file is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with haserl.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * ------------------------------------------------------------------------ */
+
+#ifndef H_TRANSLATE_H
+#define H_TRANSLATE_H
+
+void lookup_key (buffer_t *buf, char *key);
+void buildTranslationMap ();
+
+void uci_init();
+char* uci_get(char* package, char* section, char* option);
+
+#endif
--- /dev/null	2013-06-08 00:10:27.000000000 -0400
+++ haserl-0.9.26/src/h_translate.c	2013-06-08 00:11:26.000000000 -0400
@@ -0,0 +1,384 @@
+/* --------------------------------------------------------------------------
+ * Copyright 2013 BashfulBladder (bashfulbladder@gmail.com)
+ *				Eric Bishop <eric@gargoyle-router.com>
+ * 
+ *   This file is patch to haserl to provide i18n translation for Gargoyle
+ *   router firmware.
+ *
+ *   This file is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License version 2,
+ *   as published by the Free Software Foundation.
+ *
+ *   This file is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with haserl.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * ------------------------------------------------------------------------ */
+
+#if HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <string.h>
+
+#include "common.h"
+#include <erics_tools.h>
+#include "h_translate.h"
+#include "h_error.h"
+#include "h_bash.h"
+#include "h_script.h"
+#include "haserl.h"
+
+#include <uci.h>
+
+#define strdup safe_strdup
+
+struct uci_context *ctx;
+struct uci_package *p;
+struct uci_element *e;
+
+//
+//  gen_lang_fpath takes the elements of the /www/i18n/lang/somefile.js & constructs the path in *buf.data
+//
+void gen_lang_fpath (buffer_t *buf, char *lang, char *jsfile) {
+	buffer_add (buf, global.webroot, strlen(global.webroot));
+	buffer_add (buf, "/i18n/", 6);
+	buffer_add (buf, lang, strlen(lang));
+	buffer_add (buf, "/", 1);
+	buffer_add (buf, jsfile, strlen(jsfile)+1); //null terminate
+}
+
+//
+//  simpleParseLine looks at a line & tries to figure out if there is a key and if there is a value - it could be comments or an empty line
+//  look for specific characters. A page.key comes at the beginning of the line, contains no spaces or quotes & comes before an equal sign
+//  If those criteria are met AND there was a period - thats probably a page.key. And just to be sure, check that flanking the period is a
+//  letter OR zero-nine.
+//  NOTE: in a page.key (examples = "UI.SaveSchanges", "TimeStr.TimeZones"), the key comes after the period. The key portion enters the map
+//  if there are 2 or more quotes, an equal sign & a terminating semicolon - a bonafide key-value pair has been found
+//  so enter the key-value pair into the global map store. Each line begins anew with fresh variables.
+//
+void simpleParseLine(char* aline, unsigned short len) {
+	unsigned char akey=0;
+	unsigned char aeq=0;
+	unsigned short akey_start=0;
+	unsigned short akey_len=0;
+	unsigned char aquote=0;
+	unsigned char aspace=0;
+	unsigned char aperiod=0;
+	unsigned short avalue_start=0;
+	unsigned short i;
+	//printf("%u bytes in %s\n", len, aline);
+	
+	for (i=0; i<len; i++) {
+		if (aline[0] == '/') { return; } // comment
+		
+		if (aline[i] == '.' && i>0 && i+2 < len) {
+			if (aperiod == 0 && aspace == 0 && aquote == 0 && aeq == 0 &&
+				( (aline[i-1] >= '0' && aline[i-1] <= '9') ||
+				  (aline[i-1] >= 'A' && aline[i-1] <= 'Z') || (aline[i-1] >= 'a' && aline[i-1] <= 'z') ) &&
+				( (aline[i+1] >= '0' && aline[i+1] <= '9') ||
+				  (aline[i+1] >= 'A' && aline[i+1] <= 'Z') || (aline[i+1] >= 'a' && aline[i+1] <= 'z') )  ) {
+				akey=1;
+				akey_start=i;
+			}
+			aperiod++;
+		}
+		if (aline[i] == '=') {
+			if (aeq==0) {
+				akey_len=(i-akey_start)-1;
+			}
+			aeq++;
+		}
+		if (aline[i] == '\"') {
+			if (aquote==0) {
+				avalue_start=i+1;
+			}
+			aquote++;
+		}
+		if (aline[i] == ' ') {
+			aspace++;
+		}
+		if (aline[i] == ';' && aline[i-1] == '\"') {
+			aquote++;
+			if (akey==1 && aeq>=1 && aquote>1 && akey_len>0){
+				char* strkey=(char*)calloc(akey_len<8?8:akey_len+1, sizeof(char));
+				char* strvalue=(char*)calloc((len-avalue_start)<8?8:(len-avalue_start)+1, sizeof(char));
+				if (strkey != NULL) {
+					memcpy(strkey, aline+akey_start+1, akey_len);
+				}
+				if (strvalue != NULL) {
+					memcpy(strvalue, aline+avalue_start, (i-1)-avalue_start);
+				}
+				if (strkey != NULL && strvalue != NULL) {
+					set_string_map_element(global.translationKV_map, strkey, strvalue);
+				}
+				//printf("I have %s = '%s'\n", strkey, (char*)get_string_map_element(global.translationKV_map, strkey));
+			}
+		}
+	}
+}
+
+//
+//  simpleParseFile takes the untouched raw file data & breaks it into lines (newlines, not some whacked \r) & off for parsing it goes
+//
+void simpleParseFile(char* fdata, int f_len) {
+	int i;
+	unsigned short lstart = 0;
+	unsigned short len = 0;
+	
+	for (i=0; i<f_len; i++) {
+		len++;
+		if (fdata[i] == '\n') {
+			if (f_len > 3) {
+				char* aline=(char*)calloc(len<8?8:len, sizeof(char));
+				if (aline != NULL) {
+					memcpy(aline, fdata+lstart, len);
+					simpleParseLine(aline, len-1);
+				}
+			}
+			lstart=i+1;
+			len=0;
+		}
+	}
+}
+
+//
+//  readFile does some basic housekeeping: makes sure the file is present; is not monstrously sized (strings are separated into pages
+//  It is highly unlikely a single page would *EVER* need 50k); the read-buffer was successfully allocated & the UTF-8 BOM present
+//  Note: windows users: no UTF16, UCS2... And a byte order mark please.
+//
+void readFile (char* filepath) {
+	FILE *lfile;
+	char *buf;
+	long int lf_len;
+	
+	lfile = fopen(filepath, "r");
+	if (lfile == NULL) {
+		die_with_message(NULL, NULL, "A needed translation file: '%s' was not found", filepath);
+		return; // the file was not found
+	}
+	
+	fseek(lfile, 0L, SEEK_END);
+	lf_len = ftell(lfile);
+	if (lf_len > 51200) { 
+		die_with_message(NULL, NULL, "Translate error: translation file > 50kb");
+		fclose(lfile);
+		return;
+	}
+	fseek(lfile, 0L, SEEK_SET);
+	
+	buf = (char*)calloc(lf_len, sizeof(char));
+	if(buf == NULL) { 
+		die_with_message(NULL, NULL, "Translate error: couldn't allocate buffer");
+		fclose(lfile);
+		free(buf);
+		return;
+	}
+	
+	fread(buf, sizeof(char), 3, lfile);
+	if (memcmp (buf, "\xEF\xBB\xBF", 3) == 0) {
+		fread(buf+3, sizeof(char), lf_len-3, lfile);
+		simpleParseFile(buf, (int)lf_len);
+		
+	} else {
+		die_with_message(NULL, NULL, "Translate error: '%s' No UTF-8 BOM", filepath);
+	}
+	fclose(lfile);
+	free(buf);
+}
+
+//
+//  AssertPageMapped is a simple assert which tests if there is a somepage.js key present in the map
+//  this 1 extra somepage.js key is not present in the files; it is generated after parsing the file initially
+//  so the page won't get repeatedly parsed. Once is quite enough.
+//
+unsigned char AssertPageMapped(char* page) {
+	unsigned char ret_val=0;
+	
+	if (get_string_map_element(global.translationKV_map, page) != NULL) {
+		ret_val=1;
+	}
+	return ret_val;
+}
+
+//
+//  lookup_key will use the the text inside the haserl tag to find the matching value from the global map
+//  store (global.global.translationKV_map)
+//    buff is the buffer where results will be dumped & shuffled onto echoing in the shell for direct injection into the 
+//    webpage key is the raw text from the Gargoyle webpage (trailing space apparently included): <%~ key %> or <%~ page.key %>
+//
+//  Note: the 1st key from a page-specific (non UI.key) translation requires the page.key form to parse/load/map the key-value pairs
+//
+//  First look for a period in the haserl translation tag - if present, split on the period & construct a filepath & parse
+//  No matter what, there is a space at the end of the key which will throw off a key: "key" != "key "
+//  If a value is not obtained, use what was given to us in the <%~ translate %> element
+//
+void lookup_key (buffer_t *buf, char *key) {
+	char* tvalue;
+	char** key_ptr = NULL;
+	buffer_t fpath;
+	char page_split[256], key_split[256];
+	char* kaddr=&key_split[0];
+	char* split=strchr(key++, '.');
+
+	haserl_buffer_init (&fpath);
+	memset(page_split, 0, 256);
+	memset(key_split, 0, 256);
+
+	if (split == NULL) {
+		memcpy(key_split, key, strlen(key)-1); //there's a space there between the key %>
+	} else {
+		// ah, a page_specific.key to find
+		memcpy(page_split, key, split-key);
+		memcpy(key_split, split+1, strlen(split)-2); //minus 1: the period; minus another 1 for trailing space
+		memcpy(page_split+(split-key), ".js", 3);
+		
+		if (AssertPageMapped(page_split) == 0) {
+			gen_lang_fpath(&fpath, global.fallback_lang, page_split);
+			readFile((char *)fpath.data);
+			
+			if (memcmp(global.fallback_lang, global.active_lang, strlen(global.active_lang)) != 0) {
+				buffer_reset(&fpath);
+				gen_lang_fpath(&fpath, global.active_lang, page_split);
+				readFile((char *)fpath.data);
+			}
+			// TODO: apparently, this is done on faith, because whether the page was *actually* mapped isn't tested
+			set_string_map_element(global.translationKV_map, page_split, "true");
+		}
+	}
+	key_ptr=&kaddr;
+
+	tvalue=get_string_map_element(global.translationKV_map, *key_ptr);
+	if (tvalue != NULL) {
+		// a mapped key-value pair was found
+		bash_echo (buf, tvalue, strlen(tvalue));
+	} else {
+		// an exisinng value for the key wasn't found. Regurgitate the key - if the key had a period (split!=null), then use split key
+		bash_echo (buf, split==NULL?key:&key_split[0], strlen(split==NULL?key:&key_split[0]));
+	}
+	buffer_destroy(&fpath);
+	return;
+}
+
+//
+//  buildTranslationMap runs if any <%~ translate %> tag is discovered
+//  Preprocessing doesn't capture if there are page_specific tags, but it is likely to common elements in strings.js
+//  Here the fallback_lang/strings.js key-value pairs will be read & active_language/strings.js values will clobber
+//  the fallback_lang values. If there were page_specific.keys - they will be read in later in lookup_key
+//  Finally, add 1 extra key-value pair - the ability to check if a page is already mapped.
+//
+void buildTranslationMap () {
+	if (global.fallback_lang == NULL) {
+		die_with_message (NULL, NULL, "The fallback language was not set for gargoyle.global.fallback_lang");
+	} else if (global.active_lang == NULL) {
+		die_with_message (NULL, NULL, "The active language was not set for gargoyle.global.language");
+	}
+
+	buffer_t fpath;
+	haserl_buffer_init (&fpath);
+	global.translationKV_map = initialize_string_map(1);
+	
+	gen_lang_fpath(&fpath, global.fallback_lang, "strings.js");
+	readFile((char *)fpath.data);
+	
+	if (memcmp(global.fallback_lang, global.active_lang, strlen(global.active_lang)) != 0) {
+		buffer_reset(&fpath);
+		gen_lang_fpath(&fpath, global.active_lang, "strings.js");
+		readFile((char *)fpath.data);
+	}
+	set_string_map_element(global.translationKV_map, "strings.js", "true");
+	
+	//printf("Test: SaveChanges='%s'\n", (char*)get_string_map_element(global.translationKV_map, "SaveChanges"));
+}
+
+
+/*****************************	from gargoyle_header_footer	*************************************************/
+//
+// this function dynamically allocates memory for
+// the option string, but since this program exits
+// almost immediately (after printing variable info)
+// the massive memory leak we're opening up shouldn't
+// cause any problems.  This is your reminder/warning
+// that this might be an issue if you use this code to
+// do anything fancy.
+char* get_option_value_string(struct uci_option* uopt)
+{
+	char* opt_str = NULL;
+	if(uopt->type == UCI_TYPE_STRING)
+	{
+		opt_str = strdup(uopt->v.string);
+	}
+	if(uopt->type == UCI_TYPE_LIST)
+	{
+		struct uci_element* e;
+		uci_foreach_element(&uopt->v.list, e)
+		{
+			if(opt_str == NULL)
+			{
+				opt_str = strdup(e->name);
+			}
+			else
+			{
+				char* tmp;
+				tmp = dynamic_strcat(3, opt_str, " ", e->name);
+				free(opt_str);
+				opt_str = tmp;
+			}
+		}
+	}
+	
+	/* escape backslash characters & quote characters so javascript can parse variables properly */
+	char* tmp = opt_str;
+	opt_str = dynamic_replace(opt_str, "\\", "\\\\");
+	free(tmp);
+	tmp = opt_str;
+	opt_str = dynamic_replace(opt_str, "\"", "\\\"");
+	free(tmp);
+	
+	
+	return opt_str;
+}
+
+int get_uci_option(struct uci_context* ctx, struct uci_element** e, struct uci_package *p, char* package_name, char* section_name, char* option_name)
+{
+	struct uci_ptr ptr;
+	char* lookup_str = dynamic_strcat(5, package_name, ".", section_name, ".", option_name);
+	int ret_value = uci_lookup_ptr(ctx, &ptr, lookup_str, 1);
+	if(ret_value == UCI_OK)
+	{
+		if( !(ptr.flags & UCI_LOOKUP_COMPLETE))
+		{
+			ret_value = UCI_ERR_NOTFOUND;
+		}
+		else
+		{
+			*e = (struct uci_element*)ptr.o;
+		}
+	}
+	free(lookup_str);
+	
+	return ret_value;
+}
+/******************************************************************************/
+
+
+void uci_init() {
+	ctx = uci_alloc_context();
+}
+
+char* uci_get(char* package, char* section, char* option) {
+	p = NULL;
+	e = NULL;
+	if(get_uci_option(ctx, &e, p, package, section, option) == UCI_OK)
+	{
+		return get_option_value_string(uci_to_option(e));
+	}
+	return NULL;
+}
