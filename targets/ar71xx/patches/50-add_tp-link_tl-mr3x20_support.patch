--- a/target/linux/ar71xx/base-files/etc/defconfig/tl-mr3220/network	1970-01-01 01:00:00.000000000 +0100
+++ b/target/linux/ar71xx/base-files/etc/defconfig/tl-mr3220/network	2011-03-28 17:36:09.000000000 +0200
@@ -0,0 +1,24 @@
+config interface loopback
+	option ifname	lo
+	option proto	static
+	option ipaddr	127.0.0.1
+	option netmask	255.0.0.0
+
+config interface lan
+	option ifname	eth0
+	option type	bridge
+	option proto	static
+	option ipaddr	192.168.1.1
+	option netmask	255.255.255.0
+
+config interface wan
+	option ifname	eth1
+	option proto	dhcp
+
+config switch eth0
+	option enable_vlan	1
+
+config switch_vlan
+	option device	eth0
+	option vlan	1
+	option ports	"0 1 2 3 4"
--- a/target/linux/ar71xx/base-files/etc/defconfig/tl-mr3420/network	1970-01-01 01:00:00.000000000 +0100
+++ b/target/linux/ar71xx/base-files/etc/defconfig/tl-mr3420/network	2011-03-28 16:48:52.000000000 +0200
@@ -0,0 +1,24 @@
+config interface loopback
+	option ifname	lo
+	option proto	static
+	option ipaddr	127.0.0.1
+	option netmask	255.0.0.0
+
+config interface lan
+	option ifname	eth0
+	option type	bridge
+	option proto	static
+	option ipaddr	192.168.1.1
+	option netmask	255.255.255.0
+
+config interface wan
+	option ifname	eth1
+	option proto	dhcp
+
+config switch eth0
+	option enable_vlan	1
+
+config switch_vlan
+	option device	eth0
+	option vlan	1
+	option ports	"0 1 2 3 4"
--- a/target/linux/ar71xx/base-files/etc/diag.sh	2011-03-28 16:47:21.000000000 +0200
+++ b/target/linux/ar71xx/base-files/etc/diag.sh	2011-03-28 17:36:09.000000000 +0200
@@ -78,6 +78,9 @@
 	tl-wr741nd)
 		status_led="tl-wr741nd:green:system"
 		;;
+	tl-mr3220 | tl-mr3420)
+		status_led="tl-mr3x20:green:system"
+		;;
 	tl-wr841n-v1)
 		status_led="tl-wr841n:green:system"
 		;;
--- a/target/linux/ar71xx/base-files/lib/ar71xx.sh	2011-03-28 16:47:21.000000000 +0200
+++ b/target/linux/ar71xx/base-files/lib/ar71xx.sh	2011-03-28 17:36:09.000000000 +0200
@@ -94,6 +94,12 @@
 	*"TL-WR841N v1")
 		name="tl-wr841n-v1"
 		;;
+	*TL-MR3220)
+		name="tl-mr3220"
+		;;
+	*TL-MR3420)
+		name="tl-mr3420"
+		;;
 	*TL-WR941ND)
 		name="tl-wr941nd"
 		;;
--- a/target/linux/ar71xx/base-files/lib/upgrade/platform.sh	2011-03-28 16:47:21.000000000 +0200
+++ b/target/linux/ar71xx/base-files/lib/upgrade/platform.sh	2011-03-28 17:48:12.000000000 +0200
@@ -76,7 +76,7 @@
 		}
 		return 0
 		;;
-	tl-wr741nd | tl-wr841n-v1 | tl-wr941nd | tl-wr1043nd)
+	tl-mr3220 | tl-mr3420 | tl-wr741nd | tl-wr841n-v1 | tl-wr941nd | tl-wr1043nd)
 		[ "$magic" != "0100" ] && {
 			echo "Invalid image type."
 			return 1
--- a/target/linux/ar71xx/config-2.6.32	2011-03-28 16:47:21.000000000 +0200
+++ b/target/linux/ar71xx/config-2.6.32	2011-03-28 17:36:09.000000000 +0200
@@ -34,6 +34,7 @@
 CONFIG_AR71XX_MACH_TL_WR741ND=y
 CONFIG_AR71XX_MACH_TL_WR841N_V1=y
 CONFIG_AR71XX_MACH_TL_WR941ND=y
+CONFIG_AR71XX_MACH_TL_MR3X20=y
 CONFIG_AR71XX_MACH_UBNT=y
 CONFIG_AR71XX_MACH_WNDR3700=y
 CONFIG_AR71XX_MACH_WNR2000=y
@@ -42,6 +43,7 @@
 CONFIG_AR71XX_MACH_WRT400N=y
 CONFIG_AR71XX_MACH_WZR_HP_G300NH=y
 CONFIG_AR71XX_NVRAM=y
+CONFIG_AR71XX_PCI_ATH9K_FIXUP=y
 CONFIG_AR71XX_WDT=y
 CONFIG_AR8216_PHY=y
 # CONFIG_ARCH_HAS_ILOG2_U32 is not set
--- a/target/linux/ar71xx/files/arch/mips/ar71xx/dev-ap91-pci.c	2011-03-28 16:47:20.000000000 +0200
+++ b/target/linux/ar71xx/files/arch/mips/ar71xx/dev-ap91-pci.c	2011-03-28 16:48:52.000000000 +0200
@@ -16,12 +16,12 @@
 #include <asm/mach-ar71xx/pci.h>
 
 #include "dev-ap91-pci.h"
+#include "pci-ath9k-fixup.h"
 
 static struct ath9k_platform_data ap91_wmac_data = {
 	.led_pin = -1,
 };
 static char ap91_wmac_mac[6];
-static int ap91_pci_fixup_enabled;
 
 static struct ar71xx_pci_irq ap91_pci_irqs[] __initdata = {
 	{
@@ -33,7 +33,7 @@
 
 static int ap91_pci_plat_dev_init(struct pci_dev *dev)
 {
-	switch(PCI_SLOT(dev->devfn)) {
+	switch (PCI_SLOT(dev->devfn)) {
 	case 0:
 		dev->dev.platform_data = &ap91_wmac_data;
 		break;
@@ -42,62 +42,6 @@
 	return 0;
 }
 
-static void ap91_pci_fixup(struct pci_dev *dev)
-{
-	void __iomem *mem;
-	u16 *cal_data;
-	u16 cmd;
-	u32 val;
-
-	if (!ap91_pci_fixup_enabled)
-		return;
-
-	printk(KERN_INFO "PCI: fixup device %s\n", pci_name(dev));
-
-	cal_data = ap91_wmac_data.eeprom_data;
-	if (*cal_data != 0xa55a) {
-		printk(KERN_ERR "PCI: no calibration data found for %s\n",
-		       pci_name(dev));
-		return;
-	}
-
-	mem = ioremap(AR71XX_PCI_MEM_BASE, 0x10000);
-	if (!mem) {
-		printk(KERN_ERR "PCI: ioremap error for device %s\n",
-		       pci_name(dev));
-		return;
-	}
-
-	/* Setup the PCI device to allow access to the internal registers */
-	pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, 0xffff);
-	pci_read_config_word(dev, PCI_COMMAND, &cmd);
-	cmd |= PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY;
-	pci_write_config_word(dev, PCI_COMMAND, cmd);
-
-        /* set pointer to first reg address */
-	cal_data += 3;
-	while (*cal_data != 0xffff) {
-		u32 reg;
-		reg = *cal_data++;
-		val = *cal_data++;
-		val |= (*cal_data++) << 16;
-
-		__raw_writel(val, mem + reg);
-		udelay(100);
-	}
-
-	pci_read_config_dword(dev, PCI_VENDOR_ID, &val);
-	dev->vendor = val & 0xffff;
-	dev->device = (val >> 16) & 0xffff;
-
-	pci_read_config_dword(dev, PCI_CLASS_REVISION, &val);
-	dev->revision = val & 0xff;
-	dev->class = val >> 8; /* upper 3 bytes */
-
-	iounmap(mem);
-}
-DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_ATHEROS, PCI_ANY_ID, ap91_pci_fixup);
-
 __init void ap91_pci_setup_wmac_led_pin(int pin)
 {
 	ap91_wmac_data.led_pin = pin;
@@ -123,5 +67,5 @@
 	ar71xx_pci_plat_dev_init = ap91_pci_plat_dev_init;
 	ar71xx_pci_init(ARRAY_SIZE(ap91_pci_irqs), ap91_pci_irqs);
 
-	ap91_pci_fixup_enabled = 1;
+	pci_enable_ath9k_fixup(0, ap91_wmac_data.eeprom_data);
 }
--- a/target/linux/ar71xx/files/arch/mips/ar71xx/devices.c	2011-03-28 16:47:20.000000000 +0200
+++ b/target/linux/ar71xx/files/arch/mips/ar71xx/devices.c	2011-03-28 16:48:52.000000000 +0200
@@ -22,7 +22,7 @@
 
 #include "devices.h"
 
-static u8 ar71xx_mac_base[ETH_ALEN] __initdata;
+unsigned char ar71xx_mac_base[ETH_ALEN] __initdata;
 
 static struct resource ar71xx_uart_resources[] = {
 	{
@@ -86,7 +86,13 @@
 {
 	switch (ar71xx_soc) {
 	case AR71XX_SOC_AR7240:
+		ar71xx_mdio_data.is_ar7240 = 1;
+		break;
 	case AR71XX_SOC_AR7241:
+		ar71xx_mdio_data.is_ar7240 = 1;
+		ar71xx_mdio_resources[0].start = AR71XX_GE1_BASE;
+		ar71xx_mdio_resources[0].end = AR71XX_GE1_BASE + 0x200 - 1;
+		break;
 	case AR71XX_SOC_AR7242:
 		ar71xx_mdio_data.is_ar7240 = 1;
 		break;
@@ -447,6 +453,13 @@
 		pdata->set_pll =  id ? ar724x_set_pll_ge1
 				     : ar724x_set_pll_ge0;
 		pdata->is_ar724x = 1;
+
+		if (!pdata->fifo_cfg1)
+			pdata->fifo_cfg1 = 0x0010ffff;
+		if (!pdata->fifo_cfg2)
+			pdata->fifo_cfg2 = 0x015500aa;
+		if (!pdata->fifo_cfg3)
+			pdata->fifo_cfg3 = 0x01f00140;
 		break;
 
 	case AR71XX_SOC_AR9130:
@@ -483,10 +496,7 @@
 		break;
 	}
 
-	if (is_valid_ether_addr(ar71xx_mac_base)) {
-		memcpy(pdata->mac_addr, ar71xx_mac_base, ETH_ALEN);
-		pdata->mac_addr[5] += ar71xx_eth_instance;
-	} else {
+	if (!is_valid_ether_addr(pdata->mac_addr)) {
 		random_ether_addr(pdata->mac_addr);
 		printk(KERN_DEBUG
 			"ar71xx: using random MAC address for eth%d\n",
@@ -573,3 +583,24 @@
 	return 1;
 }
 __setup("kmac=", ar71xx_kmac_setup);
+
+void __init ar71xx_init_mac(unsigned char *dst, const unsigned char *src,
+			    unsigned offset)
+{
+	u32 t;
+
+	if (!is_valid_ether_addr(src)) {
+		memset(dst, '\0', ETH_ALEN);
+		return;
+	}
+
+	t = (((u32) src[3]) << 16) + (((u32) src[4]) << 8) + ((u32) src[5]);
+	t += offset;
+
+	dst[0] = src[0];
+	dst[1] = src[1];
+	dst[2] = src[2];
+	dst[3] = (t >> 16) & 0xff;
+	dst[4] = (t >> 8) & 0xff;
+	dst[5] = t & 0xff;
+}
--- a/target/linux/ar71xx/files/arch/mips/ar71xx/devices.h	2011-03-28 16:47:20.000000000 +0200
+++ b/target/linux/ar71xx/files/arch/mips/ar71xx/devices.h	2011-03-28 16:48:52.000000000 +0200
@@ -21,7 +21,10 @@
 			   unsigned n) __init;
 
 void ar71xx_set_mac_base(unsigned char *mac) __init;
+extern unsigned char ar71xx_mac_base[] __initdata;
 void ar71xx_parse_mac_addr(char *mac_str) __init;
+void ar71xx_init_mac(unsigned char *dst, const unsigned char *src,
+		     unsigned offset) __init;
 
 struct ar71xx_eth_pll_data {
 	u32	pll_10;
--- a/target/linux/ar71xx/files/arch/mips/ar71xx/Kconfig	2011-03-28 16:47:20.000000000 +0200
+++ b/target/linux/ar71xx/files/arch/mips/ar71xx/Kconfig	2011-03-28 17:35:53.000000000 +0200
@@ -175,6 +175,15 @@
 	select AR71XX_DEV_LEDS_GPIO
 	default n
 
+config AR71XX_MACH_TL_MR3X20
+	bool "TP-LINK TL-MR3220/3420 support"
+	select AR71XX_DEV_M25P80
+	select AR71XX_DEV_AP91_PCI if PCI
+	select AR71XX_DEV_GPIO_BUTTONS
+	select AR71XX_DEV_LEDS_GPIO
+	select AR71XX_DEV_USB
+	default n
+
 config AR71XX_MACH_TL_WR941ND
 	bool "TP-LINK TL-WR941ND support"
 	select AR71XX_DEV_M25P80
@@ -218,6 +227,7 @@
 	def_bool n
 
 config AR71XX_DEV_AP91_PCI
+	select AR71XX_PCI_ATH9K_FIXUP
 	def_bool n
 
 config AR71XX_DEV_AP94_PCI
@@ -247,4 +257,7 @@
 config AR71XX_NVRAM
 	def_bool n
 
+config AR71XX_PCI_ATH9K_FIXUP
+	def_bool n
+
 endif
--- a/target/linux/ar71xx/files/arch/mips/ar71xx/mach-tl-mr3x20.c	1970-01-01 01:00:00.000000000 +0100
+++ b/target/linux/ar71xx/files/arch/mips/ar71xx/mach-tl-mr3x20.c	2011-03-28 17:58:14.000000000 +0200
@@ -0,0 +1,164 @@
+/*
+ *  TP-LINK TL-MR3220/3420 board support
+ *
+ *  Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+
+#include "machtype.h"
+#include "devices.h"
+#include "dev-m25p80.h"
+#include "dev-ap91-pci.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-usb.h"
+
+#define TL_MR3X20_GPIO_LED_QSS		0
+#define TL_MR3X20_GPIO_LED_SYSTEM	1
+#define TL_MR3X20_GPIO_LED_3G		8
+
+#define TL_MR3X20_GPIO_BTN_RESET	11
+#define TL_MR3X20_GPIO_BTN_QSS		12
+
+#define TL_MR3X20_GPIO_USB_POWER	6
+
+#define TL_MR3X20_BUTTONS_POLL_INTERVAL	20
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition tl_mr3x20_partitions[] = {
+	{
+		.name		= "u-boot",
+		.offset		= 0,
+		.size		= 0x020000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "kernel",
+		.offset		= 0x020000,
+		.size		= 0x140000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x160000,
+		.size		= 0x290000,
+	}, {
+		.name		= "art",
+		.offset		= 0x3f0000,
+		.size		= 0x010000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "firmware",
+		.offset		= 0x020000,
+		.size		= 0x3d0000,
+	}
+};
+#define tl_mr3x20_num_partitions	ARRAY_SIZE(tl_mr3x20_partitions)
+#else
+#define tl_mr3x20_partitions		NULL
+#define tl_mr3x20_num_partitions	0
+#endif /* CONFIG_MTD_PARTITIONS */
+
+static struct flash_platform_data tl_mr3x20_flash_data = {
+	.parts		= tl_mr3x20_partitions,
+	.nr_parts	= tl_mr3x20_num_partitions,
+};
+
+static struct gpio_led tl_mr3x20_leds_gpio[] __initdata = {
+	{
+		.name		= "tl-mr3x20:green:system",
+		.gpio		= TL_MR3X20_GPIO_LED_SYSTEM,
+		.active_low	= 1,
+	}, {
+		.name		= "tl-mr3x20:green:qss",
+		.gpio		= TL_MR3X20_GPIO_LED_QSS,
+		.active_low	= 1,
+	}, {
+		.name		= "tl-mr3x20:green:3g",
+		.gpio		= TL_MR3X20_GPIO_LED_3G,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_button tl_mr3x20_gpio_buttons[] __initdata = {
+	{
+		.desc		= "reset",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.threshold	= 3,
+		.gpio		= TL_MR3X20_GPIO_BTN_RESET,
+		.active_low	= 1,
+	}, {
+		.desc		= "qss",
+		.type		= EV_KEY,
+		.code		= BTN_1,
+		.threshold	= 3,
+		.gpio		= TL_MR3X20_GPIO_BTN_QSS,
+		.active_low	= 1,
+	}
+};
+
+static void __init tl_mr3x20_setup(void)
+{
+	u8 *mac = (u8 *) KSEG1ADDR(0x1f01fc00);
+	u8 *ee = (u8 *) KSEG1ADDR(0x1fff1000);
+
+	/* enable power for the USB port */
+	gpio_request(TL_MR3X20_GPIO_USB_POWER, "USB power");
+	gpio_direction_output(TL_MR3X20_GPIO_USB_POWER, 1);
+
+	ar71xx_add_device_m25p80(&tl_mr3x20_flash_data);
+
+	ar71xx_add_device_leds_gpio(-1, ARRAY_SIZE(tl_mr3x20_leds_gpio),
+					tl_mr3x20_leds_gpio);
+
+	ar71xx_add_device_gpio_buttons(-1, TL_MR3X20_BUTTONS_POLL_INTERVAL,
+					ARRAY_SIZE(tl_mr3x20_gpio_buttons),
+					tl_mr3x20_gpio_buttons);
+
+	ar71xx_eth1_data.has_ar7240_switch = 1;
+	ar71xx_init_mac(ar71xx_eth0_data.mac_addr, mac, 0);
+	ar71xx_init_mac(ar71xx_eth1_data.mac_addr, mac, 1);
+
+	/* WAN port */
+	ar71xx_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth0_data.speed = SPEED_100;
+	ar71xx_eth0_data.duplex = DUPLEX_FULL;
+
+	/* LAN ports */
+	ar71xx_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_RMII;
+	ar71xx_eth1_data.speed = SPEED_1000;
+	ar71xx_eth1_data.duplex = DUPLEX_FULL;
+
+	ar71xx_add_device_mdio(0x0);
+	ar71xx_add_device_eth(1);
+	ar71xx_add_device_eth(0);
+
+	ar71xx_add_device_usb();
+
+	ap91_pci_init(ee, mac);
+}
+
+static void __init tl_mr3220_setup(void)
+{
+	tl_mr3x20_setup();
+	ap91_pci_setup_wmac_led_pin(1);
+}
+
+MIPS_MACHINE(AR71XX_MACH_TL_MR3220, "TL-MR3220", "TP-LINK TL-MR3220",
+	     tl_mr3220_setup);
+
+static void __init tl_mr3420_setup(void)
+{
+	tl_mr3x20_setup();
+	ap91_pci_setup_wmac_led_pin(0);
+}
+
+MIPS_MACHINE(AR71XX_MACH_TL_MR3420, "TL-MR3420", "TP-LINK TL-MR3420",
+	     tl_mr3420_setup);
--- a/target/linux/ar71xx/files/arch/mips/ar71xx/machtype.h	2011-03-28 16:47:20.000000000 +0200
+++ b/target/linux/ar71xx/files/arch/mips/ar71xx/machtype.h	2011-03-28 17:35:53.000000000 +0200
@@ -37,6 +37,8 @@
 	AR71XX_MACH_MZK_W300NH,	/* Planex MZK-W300NH */
 	AR71XX_MACH_TEW_632BRP,	/* TRENDnet TEW-632BRP */
 	AR71XX_MACH_TL_WR741ND,	/* TP-LINK TL-WR741ND */
+	AR71XX_MACH_TL_MR3420,	/* TP-LINK TL-MR3420 */
+	AR71XX_MACH_TL_MR3220,	/* TP-LINK TL-MR3220 */
 	AR71XX_MACH_TL_WR841N_V1, /* TP-LINK TL-WR841N v1 */
 	AR71XX_MACH_TL_WR941ND,	/* TP-LINK TL-WR941ND */
 	AR71XX_MACH_TL_WR1043ND, /* TP-LINK TL-WR1041ND */
--- a/target/linux/ar71xx/files/arch/mips/ar71xx/Makefile	2011-03-28 16:47:20.000000000 +0200
+++ b/target/linux/ar71xx/files/arch/mips/ar71xx/Makefile	2011-03-28 17:35:53.000000000 +0200
@@ -25,6 +25,7 @@
 obj-$(CONFIG_AR71XX_DEV_USB)		+= dev-usb.o
 
 obj-$(CONFIG_AR71XX_NVRAM)		+= nvram.o
+obj-$(CONFIG_AR71XX_PCI_ATH9K_FIXUP)	+= pci-ath9k-fixup.o
 
 obj-$(CONFIG_AR71XX_MACH_AP81)		+= mach-ap81.o
 obj-$(CONFIG_AR71XX_MACH_AP83)		+= mach-ap83.o
@@ -45,6 +46,7 @@
 obj-$(CONFIG_AR71XX_MACH_TL_WR941ND)	+= mach-tl-wr941nd.o
 obj-$(CONFIG_AR71XX_MACH_TL_WR1043ND)	+= mach-tl-wr1043nd.o
 obj-$(CONFIG_AR71XX_MACH_UBNT)		+= mach-ubnt.o
+obj-$(CONFIG_AR71XX_MACH_TL_MR3X20)	+= mach-tl-mr3x20.o
 obj-$(CONFIG_AR71XX_MACH_WNDR3700)	+= mach-wndr3700.o
 obj-$(CONFIG_AR71XX_MACH_WNR2000)	+= mach-wnr2000.o
 obj-$(CONFIG_AR71XX_MACH_WP543)		+= mach-wp543.o
--- a/target/linux/ar71xx/files/arch/mips/ar71xx/pci-ath9k-fixup.c	1970-01-01 01:00:00.000000000 +0100
+++ b/target/linux/ar71xx/files/arch/mips/ar71xx/pci-ath9k-fixup.c	2011-03-28 16:48:52.000000000 +0200
@@ -0,0 +1,123 @@
+/*
+ *  Atheros AP94 reference board PCI initialization
+ *
+ *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/delay.h>
+
+#include <asm/mach-ar71xx/ar71xx.h>
+#include <asm/mach-ar71xx/pci.h>
+
+struct ath9k_fixup {
+	u16		*cal_data;
+	unsigned	slot;
+};
+
+static int ath9k_num_fixups;
+static struct ath9k_fixup ath9k_fixups[2];
+
+static void ath9k_pci_fixup(struct pci_dev *dev)
+{
+	void __iomem *mem;
+	u16 *cal_data = NULL;
+	u16 cmd;
+	u32 bar0;
+	u32 val;
+	unsigned i;
+
+	for (i = 0; i < ath9k_num_fixups; i++) {
+		if (ath9k_fixups[i].cal_data == NULL)
+			continue;
+
+		if (ath9k_fixups[i].slot != PCI_SLOT(dev->devfn))
+			continue;
+
+		cal_data = ath9k_fixups[i].cal_data;
+		break;
+	}
+
+	if (cal_data == NULL)
+		return;
+
+	if (*cal_data != 0xa55a) {
+		pr_err("pci %s: invalid calibration data\n", pci_name(dev));
+		return;
+	}
+
+	pr_info("pci %s: fixup device configuration\n", pci_name(dev));
+
+	mem = ioremap(AR71XX_PCI_MEM_BASE, 0x10000);
+	if (!mem) {
+		pr_err("pci %s: ioremap error\n", pci_name(dev));
+		return;
+	}
+
+	pci_read_config_dword(dev, PCI_BASE_ADDRESS_0, &bar0);
+
+	switch (ar71xx_soc) {
+	case AR71XX_SOC_AR7161:
+		pci_write_config_dword(dev, PCI_BASE_ADDRESS_0,
+				       AR71XX_PCI_MEM_BASE);
+		break;
+	case AR71XX_SOC_AR7240:
+		pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, 0xffff);
+		break;
+
+	case AR71XX_SOC_AR7241:
+	case AR71XX_SOC_AR7242:
+		pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, 0x1000ffff);
+		break;
+
+	default:
+		BUG();
+	}
+
+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+	cmd |= PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY;
+	pci_write_config_word(dev, PCI_COMMAND, cmd);
+
+	/* set pointer to first reg address */
+	cal_data += 3;
+	while (*cal_data != 0xffff) {
+		u32 reg;
+		reg = *cal_data++;
+		val = *cal_data++;
+		val |= (*cal_data++) << 16;
+
+		__raw_writel(val, mem + reg);
+		udelay(100);
+	}
+
+	pci_read_config_dword(dev, PCI_VENDOR_ID, &val);
+	dev->vendor = val & 0xffff;
+	dev->device = (val >> 16) & 0xffff;
+
+	pci_read_config_dword(dev, PCI_CLASS_REVISION, &val);
+	dev->revision = val & 0xff;
+	dev->class = val >> 8; /* upper 3 bytes */
+
+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+	cmd &= ~(PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY);
+	pci_write_config_word(dev, PCI_COMMAND, cmd);
+
+	pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, bar0);
+
+	iounmap(mem);
+}
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_ATHEROS, PCI_ANY_ID, ath9k_pci_fixup);
+
+void __init pci_enable_ath9k_fixup(unsigned slot, u16 *cal_data)
+{
+	if (ath9k_num_fixups >= ARRAY_SIZE(ath9k_fixups))
+		return;
+
+	ath9k_fixups[ath9k_num_fixups].slot = slot;
+	ath9k_fixups[ath9k_num_fixups].cal_data = cal_data;
+	ath9k_num_fixups++;
+}
--- a/target/linux/ar71xx/files/arch/mips/ar71xx/pci-ath9k-fixup.h	1970-01-01 01:00:00.000000000 +0100
+++ b/target/linux/ar71xx/files/arch/mips/ar71xx/pci-ath9k-fixup.h	2011-03-28 16:48:52.000000000 +0200
@@ -0,0 +1,6 @@
+#ifndef _PCI_ATH9K_FIXUP
+#define _PCI_ATH9K_FIXUP
+
+void pci_enable_ath9k_fixup(unsigned slot, u16 *cal_data) __init;
+
+#endif /* _PCI_ATH9K_FIXUP */
--- a/target/linux/ar71xx/image/Makefile	2011-03-28 16:47:21.000000000 +0200
+++ b/target/linux/ar71xx/image/Makefile	2011-03-28 17:36:09.000000000 +0200
@@ -532,6 +532,14 @@
 	$(call Image/Build/Template/$(fs_64k)/$(1),Netgear,wndr3700v2,board=WNDR3700v2,wndr3700v2_mtdlayout,3701,WNDR3700v2)
 endef
 
+define Image/Build/Profile/TLMR3220V1
+	$(call Image/Build/Template/$(fs_4k)/$(1),TPLINK,tl-mr3220-v1,board=TL-MR3220,TL-MR3220v1)
+endef
+
+define Image/Build/Profile/TLMR3420V1
+	$(call Image/Build/Template/$(fs_4k)/$(1),TPLINK,tl-mr3420-v1,board=TL-MR3420,TL-MR3420v1)
+endef
+
 define Image/Build/Profile/WRT400N
 	$(call Image/Build/Template/$(fs_64k)/$(1),WRT400N,wrt400n,board=WRT400N)
 endef
@@ -562,6 +570,8 @@
 	$(call Image/Build/Profile/PB44,$(1))
 	$(call Image/Build/Profile/TEW632BRP,$(1))
 	$(call Image/Build/Profile/TEW652BRP,$(1))
+	$(call Image/Build/Profile/TLMR3220V1,$(1))
+	$(call Image/Build/Profile/TLMR3420V1,$(1))
 	$(call Image/Build/Profile/TLWR741NDV1,$(1))
 	$(call Image/Build/Profile/TLWR841NV15,$(1))
 	$(call Image/Build/Profile/TLWR841NDV3,$(1))
--- a/target/linux/ar71xx/profiles/tp-link.mk	2011-03-28 16:47:21.000000000 +0200
+++ b/target/linux/ar71xx/profiles/tp-link.mk	2011-03-28 17:36:09.000000000 +0200
@@ -5,6 +5,28 @@
 # See /LICENSE for more information.
 #
 
+define Profile/TLMR3220V1
+	NAME:=TP-LINK TL-MR3220 v1
+	PACKAGES:=kmod-ath9k wpad-mini kmod-usb-core kmod-usb2
+endef
+
+define Profile/TLMR3220V1/Description
+	Package set optimized for the TP-LINK TL-MR3220 v1.
+endef
+
+$(eval $(call Profile,TLMR3220V1))
+
+define Profile/TLMR3420V1
+	NAME:=TP-LINK TL-MR3420 v1
+	PACKAGES:=kmod-ath9k wpad-mini kmod-usb-core kmod-usb2
+endef
+
+define Profile/TLMR3420V1/Description
+	Package set optimized for the TP-LINK TL-MR3420 v1.
+endef
+
+$(eval $(call Profile,TLMR3420V1))
+
 define Profile/TLWR741NDV1
 	NAME:=TP-LINK TL-WR741ND v1
 	PACKAGES:=kmod-ath9k wpad-mini
--- a/tools/firmware-utils/src/mktplinkfw.c	2011-03-28 16:47:15.000000000 +0200
+++ b/tools/firmware-utils/src/mktplinkfw.c	2011-03-28 16:57:34.000000000 +0200
@@ -33,6 +33,8 @@
 #endif
 
 #define HEADER_VERSION_V1	0x01000000
+#define HWID_TL_MR3220_V1	0x32200001
+#define HWID_TL_MR3420_V1	0x34200001
 #define HWID_TL_WR741ND_V1	0x07410001
 #define HWID_TL_WR841N_V1_5	0x08410002
 #define HWID_TL_WR841ND_V3	0x08410003
@@ -117,6 +119,22 @@
 		.kernel_ep	= 0x80060000,
 		.rootfs_ofs	= 0x140000,
 	}, {
+		.id		= "TL-MR3220v1",
+		.hw_id		= HWID_TL_MR3220_V1,
+		.hw_rev		= 1,
+		.fw_max_len	= 0x3c0000,
+		.kernel_la	= 0x80060000,
+		.kernel_ep	= 0x80060000,
+		.rootfs_ofs	= 0x140000,
+	}, {
+		.id		= "TL-MR3420v1",
+		.hw_id		= HWID_TL_MR3420_V1,
+		.hw_rev		= 1,
+		.fw_max_len	= 0x3c0000,
+		.kernel_la	= 0x80060000,
+		.kernel_ep	= 0x80060000,
+		.rootfs_ofs	= 0x140000,
+	}, {
 		.id		= "TL-WR841Nv1.5",
 		.hw_id		= HWID_TL_WR841N_V1_5,
 		.hw_rev		= 2,
