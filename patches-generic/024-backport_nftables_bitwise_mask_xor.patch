--- /dev/null
+++ b/package/libs/libnftnl/patches/001-include_add_new_bitwise_bool_attr_to_nftables_h.patch
@@ -0,0 +1,67 @@
+From 12bd1aea5233da4f20c19e4c7e6c4ff961185ea1 Mon Sep 17 00:00:00 2001
+From: Jeremy Sowden <jeremy@azazel.net>
+Date: Wed, 13 Nov 2024 22:25:47 +0100
+Subject: include: add new bitwise boolean attributes to nf_tables.h
+
+The kernel now has native support for AND, OR and XOR bitwise
+operations.
+
+Signed-off-by: Jeremy Sowden <jeremy@azazel.net>
+Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
+---
+ include/linux/netfilter/nf_tables.h | 18 +++++++++++++++---
+ 1 file changed, 15 insertions(+), 3 deletions(-)
+
+diff --git a/include/linux/netfilter/nf_tables.h b/include/linux/netfilter/nf_tables.h
+index 9e90793..49c944e 100644
+--- a/include/linux/netfilter/nf_tables.h
++++ b/include/linux/netfilter/nf_tables.h
+@@ -564,16 +564,26 @@ enum nft_immediate_attributes {
+ /**
+  * enum nft_bitwise_ops - nf_tables bitwise operations
+  *
+- * @NFT_BITWISE_BOOL: mask-and-xor operation used to implement NOT, AND, OR and
+- *                    XOR boolean operations
++ * @NFT_BITWISE_MASK_XOR: mask-and-xor operation used to implement NOT, AND, OR
++ *                        and XOR boolean operations
+  * @NFT_BITWISE_LSHIFT: left-shift operation
+  * @NFT_BITWISE_RSHIFT: right-shift operation
++ * @NFT_BITWISE_AND: and operation
++ * @NFT_BITWISE_OR: or operation
++ * @NFT_BITWISE_XOR: xor operation
+  */
+ enum nft_bitwise_ops {
+-	NFT_BITWISE_BOOL,
++	NFT_BITWISE_MASK_XOR,
+ 	NFT_BITWISE_LSHIFT,
+ 	NFT_BITWISE_RSHIFT,
++	NFT_BITWISE_AND,
++	NFT_BITWISE_OR,
++	NFT_BITWISE_XOR,
+ };
++/*
++ * Old name for NFT_BITWISE_MASK_XOR.  Retained for backwards-compatibility.
++ */
++#define NFT_BITWISE_BOOL NFT_BITWISE_MASK_XOR
+ 
+ /**
+  * enum nft_bitwise_attributes - nf_tables bitwise expression netlink attributes
+@@ -586,6 +596,7 @@ enum nft_bitwise_ops {
+  * @NFTA_BITWISE_OP: type of operation (NLA_U32: nft_bitwise_ops)
+  * @NFTA_BITWISE_DATA: argument for non-boolean operations
+  *                     (NLA_NESTED: nft_data_attributes)
++ * @NFTA_BITWISE_SREG2: second source register (NLA_U32: nft_registers)
+  *
+  * The bitwise expression supports boolean and shift operations.  It implements
+  * the boolean operations by performing the following operation:
+@@ -609,6 +620,7 @@ enum nft_bitwise_attributes {
+ 	NFTA_BITWISE_XOR,
+ 	NFTA_BITWISE_OP,
+ 	NFTA_BITWISE_DATA,
++	NFTA_BITWISE_SREG2,
+ 	__NFTA_BITWISE_MAX
+ };
+ #define NFTA_BITWISE_MAX	(__NFTA_BITWISE_MAX - 1)
+-- 
+cgit v1.2.3
+
--- /dev/null
+++ b/package/libs/libnftnl/patches/002-expr_bitwise_rename_boolean_ops_funcs.patch
@@ -0,0 +1,153 @@
+From 638b687979befc4e2b22b92c6830ccc9bdcf41fb Mon Sep 17 00:00:00 2001
+From: Jeremy Sowden <jeremy@azazel.net>
+Date: Wed, 13 Nov 2024 22:39:12 +0100
+Subject: expr: bitwise: rename some boolean operation functions
+
+In the next patch we add support for doing AND, OR and XOR operations
+directly in the kernel, so rename some functions and an enum constant
+related to mask-and-xor boolean operations.
+
+Signed-off-by: Jeremy Sowden <jeremy@azazel.net>
+Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
+---
+ src/expr/bitwise.c            |  8 ++++----
+ tests/nft-expr_bitwise-test.c | 34 +++++++++++++++++-----------------
+ 2 files changed, 21 insertions(+), 21 deletions(-)
+
+diff --git a/src/expr/bitwise.c b/src/expr/bitwise.c
+index 1a945e9..9385219 100644
+--- a/src/expr/bitwise.c
++++ b/src/expr/bitwise.c
+@@ -198,8 +198,8 @@ nftnl_expr_bitwise_parse(struct nftnl_expr *e, struct nlattr *attr)
+ }
+ 
+ static int
+-nftnl_expr_bitwise_snprintf_bool(char *buf, size_t remain,
+-				 const struct nftnl_expr_bitwise *bitwise)
++nftnl_expr_bitwise_snprintf_mask_xor(char *buf, size_t remain,
++				     const struct nftnl_expr_bitwise *bitwise)
+ {
+ 	int offset = 0, ret;
+ 
+@@ -248,8 +248,8 @@ nftnl_expr_bitwise_snprintf(char *buf, size_t size,
+ 	int err = -1;
+ 
+ 	switch (bitwise->op) {
+-	case NFT_BITWISE_BOOL:
+-		err = nftnl_expr_bitwise_snprintf_bool(buf, size, bitwise);
++	case NFT_BITWISE_MASK_XOR:
++		err = nftnl_expr_bitwise_snprintf_mask_xor(buf, size, bitwise);
+ 		break;
+ 	case NFT_BITWISE_LSHIFT:
+ 		err = nftnl_expr_bitwise_snprintf_shift(buf, size, "<<", bitwise);
+diff --git a/tests/nft-expr_bitwise-test.c b/tests/nft-expr_bitwise-test.c
+index d98569c..04bf95c 100644
+--- a/tests/nft-expr_bitwise-test.c
++++ b/tests/nft-expr_bitwise-test.c
+@@ -22,32 +22,32 @@ static void print_err(const char *test, const char *msg)
+ 	printf("\033[31mERROR:\e[0m [%s] %s\n", test, msg);
+ }
+ 
+-static void cmp_nftnl_expr_bool(struct nftnl_expr *rule_a,
+-				struct nftnl_expr *rule_b)
++static void cmp_nftnl_expr_mask_xor(struct nftnl_expr *rule_a,
++				    struct nftnl_expr *rule_b)
+ {
+ 	uint32_t maska, maskb;
+ 	uint32_t xora, xorb;
+ 
+ 	if (nftnl_expr_get_u32(rule_a, NFTNL_EXPR_BITWISE_DREG) !=
+ 	    nftnl_expr_get_u32(rule_b, NFTNL_EXPR_BITWISE_DREG))
+-		print_err("bool", "Expr BITWISE_DREG mismatches");
++		print_err("mask & xor", "Expr BITWISE_DREG mismatches");
+ 	if (nftnl_expr_get_u32(rule_a, NFTNL_EXPR_BITWISE_SREG) !=
+ 	    nftnl_expr_get_u32(rule_b, NFTNL_EXPR_BITWISE_SREG))
+-		print_err("bool", "Expr BITWISE_SREG mismatches");
++		print_err("mask & xor", "Expr BITWISE_SREG mismatches");
+ 	if (nftnl_expr_get_u32(rule_a, NFTNL_EXPR_BITWISE_OP) !=
+ 	    nftnl_expr_get_u32(rule_b, NFTNL_EXPR_BITWISE_OP))
+-		print_err("bool", "Expr BITWISE_OP mismatches");
++		print_err("mask & xor", "Expr BITWISE_OP mismatches");
+ 	if (nftnl_expr_get_u16(rule_a, NFTNL_EXPR_BITWISE_LEN) !=
+ 	    nftnl_expr_get_u16(rule_b, NFTNL_EXPR_BITWISE_LEN))
+-		print_err("bool", "Expr BITWISE_LEN mismatches");
++		print_err("mask & xor", "Expr BITWISE_LEN mismatches");
+ 	nftnl_expr_get(rule_a, NFTNL_EXPR_BITWISE_MASK, &maska);
+ 	nftnl_expr_get(rule_b, NFTNL_EXPR_BITWISE_MASK, &maskb);
+ 	if (maska != maskb)
+-		print_err("bool", "Size of BITWISE_MASK mismatches");
++		print_err("mask & xor", "Size of BITWISE_MASK mismatches");
+ 	nftnl_expr_get(rule_a, NFTNL_EXPR_BITWISE_XOR, &xora);
+ 	nftnl_expr_get(rule_b, NFTNL_EXPR_BITWISE_XOR, &xorb);
+ 	if (xora != xorb)
+-		print_err("bool", "Size of BITWISE_XOR mismatches");
++		print_err("mask & xor", "Size of BITWISE_XOR mismatches");
+ }
+ 
+ static void cmp_nftnl_expr_lshift(struct nftnl_expr *rule_a,
+@@ -96,7 +96,7 @@ static void cmp_nftnl_expr_rshift(struct nftnl_expr *rule_a,
+ 		print_err("rshift", "Expr BITWISE_DATA mismatches");
+ }
+ 
+-static void test_bool(void)
++static void test_mask_xor(void)
+ {
+ 	struct nftnl_rule *a, *b = NULL;
+ 	struct nftnl_expr *ex = NULL;
+@@ -110,10 +110,10 @@ static void test_bool(void)
+ 	a = nftnl_rule_alloc();
+ 	b = nftnl_rule_alloc();
+ 	if (a == NULL || b == NULL)
+-		print_err("bool", "OOM");
++		print_err("mask & xor", "OOM");
+ 	ex = nftnl_expr_alloc("bitwise");
+ 	if (ex == NULL)
+-		print_err("bool", "OOM");
++		print_err("mask & xor", "OOM");
+ 
+ 	nftnl_expr_set_u32(ex, NFTNL_EXPR_BITWISE_SREG, 0x12345678);
+ 	nftnl_expr_set_u32(ex, NFTNL_EXPR_BITWISE_DREG, 0x78123456);
+@@ -128,26 +128,26 @@ static void test_bool(void)
+ 	nftnl_rule_nlmsg_build_payload(nlh, a);
+ 
+ 	if (nftnl_rule_nlmsg_parse(nlh, b) < 0)
+-		print_err("bool", "parsing problems");
++		print_err("mask & xor", "parsing problems");
+ 
+ 	iter_a = nftnl_expr_iter_create(a);
+ 	iter_b = nftnl_expr_iter_create(b);
+ 	if (iter_a == NULL || iter_b == NULL)
+-		print_err("bool", "OOM");
++		print_err("mask & xor", "OOM");
+ 
+ 	rule_a = nftnl_expr_iter_next(iter_a);
+ 	rule_b = nftnl_expr_iter_next(iter_b);
+ 	if (rule_a == NULL || rule_b == NULL)
+-		print_err("bool", "OOM");
++		print_err("mask & xor", "OOM");
+ 
+ 	if (nftnl_expr_iter_next(iter_a) != NULL ||
+ 	    nftnl_expr_iter_next(iter_b) != NULL)
+-		print_err("bool", "More 1 expr.");
++		print_err("mask & xor", "More 1 expr.");
+ 
+ 	nftnl_expr_iter_destroy(iter_a);
+ 	nftnl_expr_iter_destroy(iter_b);
+ 
+-	cmp_nftnl_expr_bool(rule_a,rule_b);
++	cmp_nftnl_expr_mask_xor(rule_a,rule_b);
+ 
+ 	nftnl_rule_free(a);
+ 	nftnl_rule_free(b);
+@@ -263,7 +263,7 @@ static void test_rshift(void)
+ 
+ int main(int argc, char *argv[])
+ {
+-	test_bool();
++	test_mask_xor();
+ 	if (!test_ok)
+ 		exit(EXIT_FAILURE);
+ 
+-- 
+cgit v1.2.3
+
--- /dev/null
+++ b/package/libs/libnftnl/patches/003-expr_bitwise_add_support_kernel_and_or_xor_ops.patch
@@ -0,0 +1,158 @@
+From f683f636a0aa8b121a9153c96cf5ca3f8e76faa5 Mon Sep 17 00:00:00 2001
+From: Jeremy Sowden <jeremy@azazel.net>
+Date: Wed, 13 Nov 2024 22:27:08 +0100
+Subject: expr: bitwise: add support for kernel space AND, OR and XOR
+ operations
+
+Hitherto, the kernel has only supported boolean operations of the form:
+
+  dst = (src & mask) ^ xor
+
+where `src` is held in a register, and `mask` and `xor` are immediate
+values.  User space has converted AND, OR and XOR operations to this
+form, and so one operand has had to be immediate.  The kernel now
+supports performing AND, OR and XOR operations directly, on one register
+and an immediate value or on two registers, so we make that support
+available to user space.
+
+Signed-off-by: Jeremy Sowden <jeremy@azazel.net>
+Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
+---
+ include/libnftnl/expr.h |  1 +
+ src/expr/bitwise.c      | 57 +++++++++++++++++++++++++++++++++++++++++++++++--
+ 2 files changed, 56 insertions(+), 2 deletions(-)
+
+diff --git a/include/libnftnl/expr.h b/include/libnftnl/expr.h
+index fba1210..1c07b54 100644
+--- a/include/libnftnl/expr.h
++++ b/include/libnftnl/expr.h
+@@ -139,6 +139,7 @@ enum {
+ 	NFTNL_EXPR_BITWISE_XOR,
+ 	NFTNL_EXPR_BITWISE_OP,
+ 	NFTNL_EXPR_BITWISE_DATA,
++	NFTNL_EXPR_BITWISE_SREG2,
+ 	__NFTNL_EXPR_BITWISE_MAX
+ };
+ 
+diff --git a/src/expr/bitwise.c b/src/expr/bitwise.c
+index 9385219..cac47a5 100644
+--- a/src/expr/bitwise.c
++++ b/src/expr/bitwise.c
+@@ -19,6 +19,7 @@
+ 
+ struct nftnl_expr_bitwise {
+ 	enum nft_registers	sreg;
++	enum nft_registers	sreg2;
+ 	enum nft_registers	dreg;
+ 	enum nft_bitwise_ops	op;
+ 	unsigned int		len;
+@@ -37,6 +38,9 @@ nftnl_expr_bitwise_set(struct nftnl_expr *e, uint16_t type,
+ 	case NFTNL_EXPR_BITWISE_SREG:
+ 		memcpy(&bitwise->sreg, data, data_len);
+ 		break;
++	case NFTNL_EXPR_BITWISE_SREG2:
++		memcpy(&bitwise->sreg2, data, sizeof(bitwise->sreg2));
++		break;
+ 	case NFTNL_EXPR_BITWISE_DREG:
+ 		memcpy(&bitwise->dreg, data, data_len);
+ 		break;
+@@ -66,6 +70,9 @@ nftnl_expr_bitwise_get(const struct nftnl_expr *e, uint16_t type,
+ 	case NFTNL_EXPR_BITWISE_SREG:
+ 		*data_len = sizeof(bitwise->sreg);
+ 		return &bitwise->sreg;
++	case NFTNL_EXPR_BITWISE_SREG2:
++		*data_len = sizeof(bitwise->sreg2);
++		return &bitwise->sreg2;
+ 	case NFTNL_EXPR_BITWISE_DREG:
+ 		*data_len = sizeof(bitwise->dreg);
+ 		return &bitwise->dreg;
+@@ -98,6 +105,7 @@ static int nftnl_expr_bitwise_cb(const struct nlattr *attr, void *data)
+ 
+ 	switch(type) {
+ 	case NFTA_BITWISE_SREG:
++	case NFTA_BITWISE_SREG2:
+ 	case NFTA_BITWISE_DREG:
+ 	case NFTA_BITWISE_OP:
+ 	case NFTA_BITWISE_LEN:
+@@ -123,6 +131,8 @@ nftnl_expr_bitwise_build(struct nlmsghdr *nlh, const struct nftnl_expr *e)
+ 
+ 	if (e->flags & (1 << NFTNL_EXPR_BITWISE_SREG))
+ 		mnl_attr_put_u32(nlh, NFTA_BITWISE_SREG, htonl(bitwise->sreg));
++	if (e->flags & (1 << NFTNL_EXPR_BITWISE_SREG2))
++		mnl_attr_put_u32(nlh, NFTA_BITWISE_SREG2, htonl(bitwise->sreg2));
+ 	if (e->flags & (1 << NFTNL_EXPR_BITWISE_DREG))
+ 		mnl_attr_put_u32(nlh, NFTA_BITWISE_DREG, htonl(bitwise->dreg));
+ 	if (e->flags & (1 << NFTNL_EXPR_BITWISE_OP))
+@@ -169,6 +179,10 @@ nftnl_expr_bitwise_parse(struct nftnl_expr *e, struct nlattr *attr)
+ 		bitwise->sreg = ntohl(mnl_attr_get_u32(tb[NFTA_BITWISE_SREG]));
+ 		e->flags |= (1 << NFTNL_EXPR_BITWISE_SREG);
+ 	}
++	if (tb[NFTA_BITWISE_SREG2]) {
++		bitwise->sreg2 = ntohl(mnl_attr_get_u32(tb[NFTA_BITWISE_SREG2]));
++		e->flags |= (1 << NFTNL_EXPR_BITWISE_SREG2);
++	}
+ 	if (tb[NFTA_BITWISE_DREG]) {
+ 		bitwise->dreg = ntohl(mnl_attr_get_u32(tb[NFTA_BITWISE_DREG]));
+ 		e->flags |= (1 << NFTNL_EXPR_BITWISE_DREG);
+@@ -240,6 +254,31 @@ nftnl_expr_bitwise_snprintf_shift(char *buf, size_t remain, const char *op,
+ 	return offset;
+ }
+ 
++static int
++nftnl_expr_bitwise_snprintf_bool(char *buf, size_t remain, const char *op,
++				 const struct nftnl_expr *e,
++				 const struct nftnl_expr_bitwise *bitwise)
++{
++	int offset = 0, ret;
++
++	ret = snprintf(buf, remain, "reg %u = ( reg %u %s ",
++		       bitwise->dreg, bitwise->sreg, op);
++	SNPRINTF_BUFFER_SIZE(ret, remain, offset);
++
++	if (e->flags & (1 << NFTNL_EXPR_BITWISE_SREG2))
++		ret = snprintf(buf + offset, remain, "reg %u ", bitwise->sreg2);
++	else
++		ret = nftnl_data_reg_snprintf(buf + offset, remain,
++					      &bitwise->data,
++					      0, DATA_VALUE);
++	SNPRINTF_BUFFER_SIZE(ret, remain, offset);
++
++	ret = snprintf(buf + offset, remain, ") ");
++	SNPRINTF_BUFFER_SIZE(ret, remain, offset);
++
++	return offset;
++}
++
+ static int
+ nftnl_expr_bitwise_snprintf(char *buf, size_t size,
+ 			    uint32_t flags, const struct nftnl_expr *e)
+@@ -252,10 +291,24 @@ nftnl_expr_bitwise_snprintf(char *buf, size_t size,
+ 		err = nftnl_expr_bitwise_snprintf_mask_xor(buf, size, bitwise);
+ 		break;
+ 	case NFT_BITWISE_LSHIFT:
+-		err = nftnl_expr_bitwise_snprintf_shift(buf, size, "<<", bitwise);
++		err = nftnl_expr_bitwise_snprintf_shift(buf, size, "<<",
++							bitwise);
+ 		break;
+ 	case NFT_BITWISE_RSHIFT:
+-		err = nftnl_expr_bitwise_snprintf_shift(buf, size, ">>", bitwise);
++		err = nftnl_expr_bitwise_snprintf_shift(buf, size, ">>",
++							bitwise);
++		break;
++	case NFT_BITWISE_AND:
++		err = nftnl_expr_bitwise_snprintf_bool(buf, size, "&", e,
++						       bitwise);
++		break;
++	case NFT_BITWISE_OR:
++		err = nftnl_expr_bitwise_snprintf_bool(buf, size, "|", e,
++						       bitwise);
++		break;
++	case NFT_BITWISE_XOR:
++		err = nftnl_expr_bitwise_snprintf_bool(buf, size, "^", e,
++						       bitwise);
+ 		break;
+ 	}
+ 
+-- 
+cgit v1.2.3
+
--- /dev/null
+++ b/package/network/utils/nftables/patches/002-allow_binop_expr_variable_rhs_operands.patch
@@ -0,0 +1,1013 @@
+From 54bfc38c522babe709e951f1fd128ff725b36704 Mon Sep 17 00:00:00 2001
+From: Jeremy Sowden <jeremy@azazel.net>
+Date: Tue, 19 Nov 2024 00:18:28 +0100
+Subject: src: allow binop expressions with variable right-hand operands
+
+Hitherto, the kernel has required constant values for the `xor` and
+`mask` attributes of boolean bitwise expressions.  This has meant that
+the right-hand operand of a boolean binop must be constant.  Now the
+kernel has support for AND, OR and XOR operations with right-hand
+operands passed via registers, we can relax this restriction.  Allow
+non-constant right-hand operands if the left-hand operand is not
+constant, e.g.:
+
+  ct mark & 0xffff0000 | meta mark & 0xffff
+
+The kernel now supports performing AND, OR and XOR operations directly,
+on one register and an immediate value or on two registers, so we need
+to be able to generate and parse bitwise boolean expressions of this
+form.
+
+If a boolean operation has a constant RHS, we continue to send a
+mask-and-xor expression to the kernel.
+
+Add tests for {ct,meta} mark with variable RHS operands.
+
+JSON support is also included.
+
+This requires Linux kernel >= 6.13-rc.
+
+[ Originally posted as patch 1/8 and 6/8 which has been collapsed and
+  simplified to focus on initial {ct,meta} mark support. Tests have
+  been extracted from 8/8 including a tests/py fix to payload output
+  due to incorrect output in original patchset. JSON support has been
+  extracted from patch 7/8 --pablo]
+
+Signed-off-by: Jeremy Sowden <jeremy@azazel.net>
+Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
+---
+ include/linux/netfilter/nf_tables.h                | 19 ++++++-
+ src/evaluate.c                                     | 52 ++++++++++++------
+ src/netlink_delinearize.c                          | 64 +++++++++++++++++-----
+ src/netlink_linearize.c                            | 61 +++++++++++++++++----
+ src/parser_json.c                                  |  4 +-
+ tests/py/any/ct.t                                  |  3 +
+ tests/py/any/ct.t.json                             | 60 ++++++++++++++++++++
+ tests/py/any/ct.t.payload                          | 15 +++++
+ tests/py/inet/meta.t                               |  2 +
+ tests/py/inet/meta.t.json                          | 37 +++++++++++++
+ tests/py/inet/meta.t.payload                       |  9 +++
+ tests/py/ip/ct.t                                   |  2 +
+ tests/py/ip/ct.t.json                              | 32 +++++++++++
+ tests/py/ip/ct.t.payload                           | 11 ++++
+ tests/py/ip6/ct.t                                  |  1 +
+ tests/py/ip6/ct.t.json                             | 32 +++++++++++
+ tests/py/ip6/ct.t.payload                          | 12 ++++
+ tests/shell/features/bitwise_multireg.nft          |  5 ++
+ tests/shell/testcases/bitwise/0040mark_binop_10    | 13 +++++
+ tests/shell/testcases/bitwise/0040mark_binop_11    | 13 +++++
+ tests/shell/testcases/bitwise/0040mark_binop_12    | 13 +++++
+ tests/shell/testcases/bitwise/0040mark_binop_13    | 13 +++++
+ tests/shell/testcases/bitwise/0044payload_binop_2  | 13 +++++
+ tests/shell/testcases/bitwise/0044payload_binop_5  | 13 +++++
+ .../testcases/bitwise/dumps/0040mark_binop_10.nft  |  6 ++
+ .../testcases/bitwise/dumps/0040mark_binop_11.nft  |  6 ++
+ .../testcases/bitwise/dumps/0040mark_binop_12.nft  |  6 ++
+ .../testcases/bitwise/dumps/0040mark_binop_13.nft  |  6 ++
+ .../bitwise/dumps/0044payload_binop_2.nft          |  6 ++
+ .../bitwise/dumps/0044payload_binop_5.nft          |  6 ++
+ 30 files changed, 489 insertions(+), 46 deletions(-)
+ create mode 100644 tests/shell/features/bitwise_multireg.nft
+ create mode 100755 tests/shell/testcases/bitwise/0040mark_binop_10
+ create mode 100755 tests/shell/testcases/bitwise/0040mark_binop_11
+ create mode 100755 tests/shell/testcases/bitwise/0040mark_binop_12
+ create mode 100755 tests/shell/testcases/bitwise/0040mark_binop_13
+ create mode 100755 tests/shell/testcases/bitwise/0044payload_binop_2
+ create mode 100755 tests/shell/testcases/bitwise/0044payload_binop_5
+ create mode 100644 tests/shell/testcases/bitwise/dumps/0040mark_binop_10.nft
+ create mode 100644 tests/shell/testcases/bitwise/dumps/0040mark_binop_11.nft
+ create mode 100644 tests/shell/testcases/bitwise/dumps/0040mark_binop_12.nft
+ create mode 100644 tests/shell/testcases/bitwise/dumps/0040mark_binop_13.nft
+ create mode 100644 tests/shell/testcases/bitwise/dumps/0044payload_binop_2.nft
+ create mode 100644 tests/shell/testcases/bitwise/dumps/0044payload_binop_5.nft
+
+diff --git a/include/linux/netfilter/nf_tables.h b/include/linux/netfilter/nf_tables.h
+index c62e6ac5..f57963e8 100644
+--- a/include/linux/netfilter/nf_tables.h
++++ b/include/linux/netfilter/nf_tables.h
+@@ -557,16 +557,27 @@ enum nft_immediate_attributes {
+ /**
+  * enum nft_bitwise_ops - nf_tables bitwise operations
+  *
+- * @NFT_BITWISE_BOOL: mask-and-xor operation used to implement NOT, AND, OR and
+- *                    XOR boolean operations
++ * @NFT_BITWISE_MASK_XOR: mask-and-xor operation used to implement NOT, AND, OR
++ *                        and XOR boolean operations
+  * @NFT_BITWISE_LSHIFT: left-shift operation
+  * @NFT_BITWISE_RSHIFT: right-shift operation
++ * @NFT_BITWISE_AND: and operation
++ * @NFT_BITWISE_OR: or operation
++ * @NFT_BITWISE_XOR: xor operation
+  */
+ enum nft_bitwise_ops {
+-	NFT_BITWISE_BOOL,
++	NFT_BITWISE_MASK_XOR,
+ 	NFT_BITWISE_LSHIFT,
+ 	NFT_BITWISE_RSHIFT,
++	NFT_BITWISE_AND,
++	NFT_BITWISE_OR,
++	NFT_BITWISE_XOR,
+ };
++/*
++ * Old name for NFT_BITWISE_MASK_XOR, predating the addition of NFT_BITWISE_AND,
++ * NFT_BITWISE_OR and NFT_BITWISE_XOR.  Retained for backwards-compatibility.
++ */
++#define NFT_BITWISE_BOOL NFT_BITWISE_MASK_XOR
+ 
+ /**
+  * enum nft_bitwise_attributes - nf_tables bitwise expression netlink attributes
+@@ -579,6 +590,7 @@ enum nft_bitwise_ops {
+  * @NFTA_BITWISE_OP: type of operation (NLA_U32: nft_bitwise_ops)
+  * @NFTA_BITWISE_DATA: argument for non-boolean operations
+  *                     (NLA_NESTED: nft_data_attributes)
++ * @NFTA_BITWISE_SREG2: second source register (NLA_U32: nft_registers)
+  *
+  * The bitwise expression supports boolean and shift operations.  It implements
+  * the boolean operations by performing the following operation:
+@@ -602,6 +614,7 @@ enum nft_bitwise_attributes {
+ 	NFTA_BITWISE_XOR,
+ 	NFTA_BITWISE_OP,
+ 	NFTA_BITWISE_DATA,
++	NFTA_BITWISE_SREG2,
+ 	__NFTA_BITWISE_MAX
+ };
+ #define NFTA_BITWISE_MAX	(__NFTA_BITWISE_MAX - 1)
+diff --git a/src/evaluate.c b/src/evaluate.c
+index 593a0140..cd3619a2 100644
+--- a/src/evaluate.c
++++ b/src/evaluate.c
+@@ -1487,16 +1487,18 @@ static int expr_evaluate_bitwise(struct eval_ctx *ctx, struct expr **expr)
+ 	op->byteorder = byteorder;
+ 	op->len	      = max_len;
+ 
+-	if (expr_is_constant(left))
++	if (expr_is_constant(left) && expr_is_constant(op->right))
+ 		return constant_binop_simplify(ctx, expr);
+ 	return 0;
+ }
+ 
+ /*
+- * Binop expression: both sides must be of integer base type. The left
+- * hand side may be either constant or non-constant; in case its constant
+- * it must be a singleton. The ride hand side must always be a constant
+- * singleton.
++ * Binop expression: both sides must be of integer base type. The left-hand side
++ * may be either constant or non-constant; if it is constant, it must be a
++ * singleton.  For bitwise operations, the right-hand side must be constant if
++ * the left-hand side is constant; the right-hand side may be constant or
++ * non-constant, if the left-hand side is non-constant; for shifts, the
++ * right-hand side must be constant; if it is constant, it must be a singleton.
+  */
+ static int expr_evaluate_binop(struct eval_ctx *ctx, struct expr **expr)
+ {
+@@ -1527,6 +1529,13 @@ static int expr_evaluate_binop(struct eval_ctx *ctx, struct expr **expr)
+ 		return -1;
+ 	right = op->right;
+ 
++	/* evaluation expects constant to the right hand side. */
++	if (expr_is_constant(left) && !expr_is_constant(right)) {
++		range_expr_swap_values(op);
++		left = op->left;
++		right = op->right;
++	}
++
+ 	switch (expr_basetype(left)->type) {
+ 	case TYPE_INTEGER:
+ 	case TYPE_STRING:
+@@ -1544,17 +1553,6 @@ static int expr_evaluate_binop(struct eval_ctx *ctx, struct expr **expr)
+ 					 "for %s expressions",
+ 					 sym, expr_name(left));
+ 
+-	if (!expr_is_constant(right))
+-		return expr_binary_error(ctx->msgs, right, op,
+-					 "Right hand side of binary operation "
+-					 "(%s) must be constant", sym);
+-
+-	if (!expr_is_singleton(right))
+-		return expr_binary_error(ctx->msgs, left, op,
+-					 "Binary operation (%s) is undefined "
+-					 "for %s expressions",
+-					 sym, expr_name(right));
+-
+ 	if (!datatype_equal(expr_basetype(left), expr_basetype(right)))
+ 		return expr_binary_error(ctx->msgs, left, op,
+ 					 "Binary operation (%s) with different base types "
+@@ -1564,11 +1562,33 @@ static int expr_evaluate_binop(struct eval_ctx *ctx, struct expr **expr)
+ 	switch (op->op) {
+ 	case OP_LSHIFT:
+ 	case OP_RSHIFT:
++		if (!expr_is_constant(right))
++			return expr_binary_error(ctx->msgs, right, op,
++						 "Right hand side of binary operation "
++						 "(%s) must be constant", sym);
++
++		if (!expr_is_singleton(right))
++			return expr_binary_error(ctx->msgs, left, op,
++						 "Binary operation (%s) is undefined "
++						 "for %s expressions",
++						 sym, expr_name(right));
++
+ 		ret = expr_evaluate_shift(ctx, expr);
+ 		break;
+ 	case OP_AND:
+ 	case OP_XOR:
+ 	case OP_OR:
++		if (expr_is_constant(left) && !expr_is_constant(right))
++			return expr_binary_error(ctx->msgs, right, op,
++						 "Right hand side of binary operation "
++						 "(%s) must be constant", sym);
++
++		if (expr_is_constant(right) && !expr_is_singleton(right))
++			return expr_binary_error(ctx->msgs, left, op,
++						 "Binary operation (%s) is undefined "
++						 "for %s expressions",
++						 sym, expr_name(right));
++
+ 		ret = expr_evaluate_bitwise(ctx, expr);
+ 		break;
+ 	default:
+diff --git a/src/netlink_delinearize.c b/src/netlink_delinearize.c
+index e3d9cfbb..db8b6bbe 100644
+--- a/src/netlink_delinearize.c
++++ b/src/netlink_delinearize.c
+@@ -455,12 +455,12 @@ static void netlink_parse_lookup(struct netlink_parse_ctx *ctx,
+ 	ctx->stmt = expr_stmt_alloc(loc, expr);
+ }
+ 
+-static struct expr *netlink_parse_bitwise_bool(struct netlink_parse_ctx *ctx,
+-					       const struct location *loc,
+-					       const struct nftnl_expr *nle,
+-					       enum nft_registers sreg,
+-					       struct expr *left)
+-
++static struct expr *
++netlink_parse_bitwise_mask_xor(struct netlink_parse_ctx *ctx,
++			       const struct location *loc,
++			       const struct nftnl_expr *nle,
++			       enum nft_registers sreg,
++			       struct expr *left)
+ {
+ 	struct nft_data_delinearize nld;
+ 	struct expr *expr, *mask, *xor, *or;
+@@ -520,10 +520,39 @@ static struct expr *netlink_parse_bitwise_bool(struct netlink_parse_ctx *ctx,
+ 	return expr;
+ }
+ 
++static struct expr *netlink_parse_bitwise_bool(struct netlink_parse_ctx *ctx,
++					       const struct location *loc,
++					       const struct nftnl_expr *nle,
++					       enum nft_bitwise_ops op,
++					       enum nft_registers sreg,
++					       struct expr *left)
++{
++	enum nft_registers sreg2;
++	struct expr *right, *expr;
++
++	sreg2 = netlink_parse_register(nle, NFTNL_EXPR_BITWISE_SREG2);
++	right = netlink_get_register(ctx, loc, sreg2);
++	if (right == NULL) {
++		netlink_error(ctx, loc,
++			      "Bitwise expression has no right-hand expression");
++		return NULL;
++	}
++
++	expr = binop_expr_alloc(loc,
++				op == NFT_BITWISE_XOR ? OP_XOR :
++				op == NFT_BITWISE_AND ? OP_AND : OP_OR,
++				left, right);
++
++	if (left->len > 0)
++		expr->len = left->len;
++
++	return expr;
++}
++
+ static struct expr *netlink_parse_bitwise_shift(struct netlink_parse_ctx *ctx,
+ 						const struct location *loc,
+ 						const struct nftnl_expr *nle,
+-						enum ops op,
++						enum nft_bitwise_ops op,
+ 						enum nft_registers sreg,
+ 						struct expr *left)
+ {
+@@ -534,7 +563,9 @@ static struct expr *netlink_parse_bitwise_shift(struct netlink_parse_ctx *ctx,
+ 	right = netlink_alloc_value(loc, &nld);
+ 	right->byteorder = BYTEORDER_HOST_ENDIAN;
+ 
+-	expr = binop_expr_alloc(loc, op, left, right);
++	expr = binop_expr_alloc(loc,
++				op == NFT_BITWISE_LSHIFT ? OP_LSHIFT : OP_RSHIFT,
++				left, right);
+ 	expr->len = nftnl_expr_get_u32(nle, NFTNL_EXPR_BITWISE_LEN) * BITS_PER_BYTE;
+ 
+ 	return expr;
+@@ -558,16 +589,19 @@ static void netlink_parse_bitwise(struct netlink_parse_ctx *ctx,
+ 	op = nftnl_expr_get_u32(nle, NFTNL_EXPR_BITWISE_OP);
+ 
+ 	switch (op) {
+-	case NFT_BITWISE_BOOL:
+-		expr = netlink_parse_bitwise_bool(ctx, loc, nle, sreg,
+-						  left);
++	case NFT_BITWISE_MASK_XOR:
++		expr = netlink_parse_bitwise_mask_xor(ctx, loc, nle, sreg,
++						      left);
+ 		break;
+-	case NFT_BITWISE_LSHIFT:
+-		expr = netlink_parse_bitwise_shift(ctx, loc, nle, OP_LSHIFT,
+-						   sreg, left);
++	case NFT_BITWISE_XOR:
++	case NFT_BITWISE_AND:
++	case NFT_BITWISE_OR:
++		expr = netlink_parse_bitwise_bool(ctx, loc, nle, op,
++						  sreg, left);
+ 		break;
++	case NFT_BITWISE_LSHIFT:
+ 	case NFT_BITWISE_RSHIFT:
+-		expr = netlink_parse_bitwise_shift(ctx, loc, nle, OP_RSHIFT,
++		expr = netlink_parse_bitwise_shift(ctx, loc, nle, op,
+ 						   sreg, left);
+ 		break;
+ 	default:
+diff --git a/src/netlink_linearize.c b/src/netlink_linearize.c
+index 77bc5149..42310115 100644
+--- a/src/netlink_linearize.c
++++ b/src/netlink_linearize.c
+@@ -664,9 +664,9 @@ static void combine_binop(mpz_t mask, mpz_t xor, const mpz_t m, const mpz_t x)
+ 	mpz_and(mask, mask, m);
+ }
+ 
+-static void netlink_gen_shift(struct netlink_linearize_ctx *ctx,
+-			      const struct expr *expr,
+-			      enum nft_registers dreg)
++static void netlink_gen_bitwise_shift(struct netlink_linearize_ctx *ctx,
++				      const struct expr *expr,
++				      enum nft_registers dreg)
+ {
+ 	enum nft_bitwise_ops op = expr->op == OP_LSHIFT ?
+ 		NFT_BITWISE_LSHIFT : NFT_BITWISE_RSHIFT;
+@@ -691,9 +691,9 @@ static void netlink_gen_shift(struct netlink_linearize_ctx *ctx,
+ 	nft_rule_add_expr(ctx, nle, &expr->location);
+ }
+ 
+-static void netlink_gen_bitwise(struct netlink_linearize_ctx *ctx,
+-				const struct expr *expr,
+-				enum nft_registers dreg)
++static void netlink_gen_bitwise_mask_xor(struct netlink_linearize_ctx *ctx,
++					 const struct expr *expr,
++					 enum nft_registers dreg)
+ {
+ 	struct expr *binops[NFT_MAX_EXPR_RECURSION];
+ 	struct nftnl_expr *nle;
+@@ -709,7 +709,7 @@ static void netlink_gen_bitwise(struct netlink_linearize_ctx *ctx,
+ 	mpz_init(tmp);
+ 
+ 	binops[n++] = left = (struct expr *) expr;
+-	while (left->etype == EXPR_BINOP && left->left != NULL &&
++	while (left->etype == EXPR_BINOP && left->left != NULL && expr_is_constant(left->right) &&
+ 	       (left->op == OP_AND || left->op == OP_OR || left->op == OP_XOR)) {
+ 		if (n == array_size(binops))
+ 			BUG("NFT_MAX_EXPR_RECURSION limit reached");
+@@ -747,7 +747,7 @@ static void netlink_gen_bitwise(struct netlink_linearize_ctx *ctx,
+ 	nle = alloc_nft_expr("bitwise");
+ 	netlink_put_register(nle, NFTNL_EXPR_BITWISE_SREG, dreg);
+ 	netlink_put_register(nle, NFTNL_EXPR_BITWISE_DREG, dreg);
+-	nftnl_expr_set_u32(nle, NFTNL_EXPR_BITWISE_OP, NFT_BITWISE_BOOL);
++	nftnl_expr_set_u32(nle, NFTNL_EXPR_BITWISE_OP, NFT_BITWISE_MASK_XOR);
+ 	nftnl_expr_set_u32(nle, NFTNL_EXPR_BITWISE_LEN, len);
+ 
+ 	netlink_gen_raw_data(mask, expr->byteorder, len, &nld);
+@@ -763,6 +763,44 @@ static void netlink_gen_bitwise(struct netlink_linearize_ctx *ctx,
+ 	nft_rule_add_expr(ctx, nle, &expr->location);
+ }
+ 
++static void netlink_gen_bitwise_bool(struct netlink_linearize_ctx *ctx,
++				     const struct expr *expr,
++				     enum nft_registers dreg)
++{
++	enum nft_registers sreg2;
++	struct nftnl_expr *nle;
++	unsigned int len;
++
++	nle = alloc_nft_expr("bitwise");
++
++	switch (expr->op) {
++	case OP_XOR:
++		nftnl_expr_set_u32(nle, NFTNL_EXPR_BITWISE_OP, NFT_BITWISE_XOR);
++		break;
++	case OP_AND:
++		nftnl_expr_set_u32(nle, NFTNL_EXPR_BITWISE_OP, NFT_BITWISE_AND);
++		break;
++	case OP_OR:
++		nftnl_expr_set_u32(nle, NFTNL_EXPR_BITWISE_OP, NFT_BITWISE_OR);
++		break;
++	default:
++		BUG("invalid binary operation %u\n", expr->op);
++	}
++
++	netlink_gen_expr(ctx, expr->left, dreg);
++	netlink_put_register(nle, NFTNL_EXPR_BITWISE_SREG, dreg);
++	netlink_put_register(nle, NFTNL_EXPR_BITWISE_DREG, dreg);
++
++	sreg2 = get_register(ctx, expr->right);
++	netlink_gen_expr(ctx, expr->right, sreg2);
++	netlink_put_register(nle, NFTNL_EXPR_BITWISE_SREG2, sreg2);
++
++	len = div_round_up(expr->len, BITS_PER_BYTE);
++	nftnl_expr_set_u32(nle, NFTNL_EXPR_BITWISE_LEN, len);
++
++	nftnl_rule_add_expr(ctx->nlr, nle);
++}
++
+ static void netlink_gen_binop(struct netlink_linearize_ctx *ctx,
+ 			      const struct expr *expr,
+ 			      enum nft_registers dreg)
+@@ -770,10 +808,13 @@ static void netlink_gen_binop(struct netlink_linearize_ctx *ctx,
+ 	switch(expr->op) {
+ 	case OP_LSHIFT:
+ 	case OP_RSHIFT:
+-		netlink_gen_shift(ctx, expr, dreg);
++		netlink_gen_bitwise_shift(ctx, expr, dreg);
+ 		break;
+ 	default:
+-		netlink_gen_bitwise(ctx, expr, dreg);
++		if (expr_is_constant(expr->right))
++			netlink_gen_bitwise_mask_xor(ctx, expr, dreg);
++		else
++			netlink_gen_bitwise_bool(ctx, expr, dreg);
+ 		break;
+ 	}
+ }
+diff --git a/src/parser_json.c b/src/parser_json.c
+index bae2c3c0..5ac5f027 100644
+--- a/src/parser_json.c
++++ b/src/parser_json.c
+@@ -1557,12 +1557,12 @@ static struct expr *json_parse_expr(struct json_ctx *ctx, json_t *root)
+ 		{ "ip option", json_parse_ip_option_expr, CTX_F_PRIMARY | CTX_F_SET_RHS | CTX_F_MANGLE | CTX_F_SES | CTX_F_CONCAT },
+ 		{ "sctp chunk", json_parse_sctp_chunk_expr, CTX_F_PRIMARY | CTX_F_SET_RHS | CTX_F_MANGLE | CTX_F_SES | CTX_F_CONCAT },
+ 		{ "dccp option", json_parse_dccp_option_expr, CTX_F_PRIMARY },
+-		{ "meta", json_parse_meta_expr, CTX_F_STMT | CTX_F_PRIMARY | CTX_F_SET_RHS | CTX_F_MANGLE | CTX_F_SES | CTX_F_MAP | CTX_F_CONCAT },
++		{ "meta", json_parse_meta_expr, CTX_F_RHS | CTX_F_STMT | CTX_F_PRIMARY | CTX_F_SET_RHS | CTX_F_MANGLE | CTX_F_SES | CTX_F_MAP | CTX_F_CONCAT },
+ 		{ "osf", json_parse_osf_expr, CTX_F_STMT | CTX_F_PRIMARY | CTX_F_MAP | CTX_F_CONCAT },
+ 		{ "ipsec", json_parse_xfrm_expr, CTX_F_PRIMARY | CTX_F_MAP | CTX_F_CONCAT },
+ 		{ "socket", json_parse_socket_expr, CTX_F_PRIMARY | CTX_F_CONCAT },
+ 		{ "rt", json_parse_rt_expr, CTX_F_STMT | CTX_F_PRIMARY | CTX_F_SET_RHS | CTX_F_SES | CTX_F_MAP | CTX_F_CONCAT },
+-		{ "ct", json_parse_ct_expr, CTX_F_STMT | CTX_F_PRIMARY | CTX_F_SET_RHS | CTX_F_MANGLE | CTX_F_SES | CTX_F_MAP | CTX_F_CONCAT },
++		{ "ct", json_parse_ct_expr, CTX_F_RHS | CTX_F_STMT | CTX_F_PRIMARY | CTX_F_SET_RHS | CTX_F_MANGLE | CTX_F_SES | CTX_F_MAP | CTX_F_CONCAT },
+ 		{ "numgen", json_parse_numgen_expr, CTX_F_STMT | CTX_F_PRIMARY | CTX_F_SET_RHS | CTX_F_SES | CTX_F_MAP | CTX_F_CONCAT },
+ 		/* below two are hash expr */
+ 		{ "jhash", json_parse_hash_expr, CTX_F_STMT | CTX_F_PRIMARY | CTX_F_SET_RHS | CTX_F_SES | CTX_F_MAP | CTX_F_CONCAT },
+diff --git a/tests/py/any/ct.t b/tests/py/any/ct.t
+index f73fa4e7..0059e49c 100644
+--- a/tests/py/any/ct.t
++++ b/tests/py/any/ct.t
+@@ -40,7 +40,9 @@ ct mark and 0x23 == 0x11;ok;ct mark & 0x00000023 == 0x00000011
+ ct mark and 0x3 != 0x1;ok;ct mark & 0x00000003 != 0x00000001
+ ct mark xor 0x23 == 0x11;ok;ct mark 0x00000032
+ ct mark xor 0x3 != 0x1;ok;ct mark != 0x00000002
++
+ ct mark set ct mark or 0x00000001;ok;ct mark set ct mark | 0x00000001
++ct mark set 0x00000001 or ct mark;ok;ct mark set ct mark | 0x00000001
+ 
+ ct mark 0x00000032;ok
+ ct mark != 0x00000032;ok
+@@ -61,6 +63,7 @@ ct mark set 0x11;ok;ct mark set 0x00000011
+ ct mark set mark;ok;ct mark set meta mark
+ ct mark set (meta mark | 0x10) << 8;ok;ct mark set (meta mark | 0x00000010) << 8
+ ct mark set mark map { 1 : 10, 2 : 20, 3 : 30 };ok;ct mark set meta mark map { 0x00000003 : 0x0000001e, 0x00000002 : 0x00000014, 0x00000001 : 0x0000000a}
++ct mark set ct mark and 0xffff0000 or meta mark and 0xffff;ok;ct mark set ct mark & 0xffff0000 | meta mark & 0x0000ffff
+ 
+ ct mark set {0x11333, 0x11};fail
+ ct zone set {123, 127};fail
+diff --git a/tests/py/any/ct.t.json b/tests/py/any/ct.t.json
+index a2a06025..ef350000 100644
+--- a/tests/py/any/ct.t.json
++++ b/tests/py/any/ct.t.json
+@@ -560,6 +560,29 @@
+     }
+ ]
+ 
++# ct mark set 0x00000001 or ct mark
++[
++    {
++        "mangle": {
++            "key": {
++                "ct": {
++                    "key": "mark"
++                }
++            },
++            "value": {
++                "|": [
++                    {
++                        "ct": {
++                            "key": "mark"
++                        }
++                    },
++                    1
++                ]
++            }
++        }
++    }
++]
++
+ # ct mark 0x00000032
+ [
+     {
+@@ -817,6 +840,43 @@
+     }
+ ]
+ 
++# ct mark set ct mark and 0xffff0000 or meta mark and 0xffff
++[
++    {
++        "mangle": {
++            "key": {
++                "ct": {
++                    "key": "mark"
++                }
++            },
++            "value": {
++                "|": [
++                    {
++                        "&": [
++                            {
++                                "ct": {
++                                    "key": "mark"
++                                }
++                            },
++                            4294901760
++                        ]
++                    },
++                    {
++                        "&": [
++                            {
++                                "meta": {
++                                    "key": "mark"
++                                }
++                            },
++                            65535
++                        ]
++                    }
++                ]
++            }
++        }
++    }
++]
++
+ # ct expiration 30s
+ [
+     {
+diff --git a/tests/py/any/ct.t.payload b/tests/py/any/ct.t.payload
+index ed868e53..14385cf7 100644
+--- a/tests/py/any/ct.t.payload
++++ b/tests/py/any/ct.t.payload
+@@ -336,6 +336,15 @@ ip test-ip4 output
+   [ lookup reg 1 set __map%d dreg 1 ]
+   [ ct set mark with reg 1 ]
+ 
++# ct mark set ct mark and 0xffff0000 or meta mark and 0xffff
++ip
++  [ ct load mark => reg 1 ]
++  [ bitwise reg 1 = ( reg 1 & 0xffff0000 ) ^ 0x00000000 ]
++  [ meta load mark => reg 2 ]
++  [ bitwise reg 2 = ( reg 2 & 0x0000ffff ) ^ 0x00000000 ]
++  [ bitwise reg 1 = ( reg 1 | reg 2 ) ]
++  [ ct set mark with reg 1 ]
++
+ # ct original bytes > 100000
+ ip test-ip4 output
+   [ ct load bytes => reg 1 , dir original ]
+@@ -497,6 +506,12 @@ ip test-ip4 output
+   [ bitwise reg 1 = ( reg 1 & 0xfffffffe ) ^ 0x00000001 ]
+   [ ct set mark with reg 1 ]
+ 
++# ct mark set 0x00000001 or ct mark
++ip test-ip4 output
++  [ ct load mark => reg 1 ]
++  [ bitwise reg 1 = ( reg 1 & 0xfffffffe ) ^ 0x00000001 ]
++  [ ct set mark with reg 1 ]
++
+ # ct id 12345
+ ip test-ip4 output
+   [ ct load unknown => reg 1 ]
+diff --git a/tests/py/inet/meta.t b/tests/py/inet/meta.t
+index 7d2515c9..5c5c11d4 100644
+--- a/tests/py/inet/meta.t
++++ b/tests/py/inet/meta.t
+@@ -31,3 +31,5 @@ meta mark set ip dscp;ok
+ meta mark set ip dscp | 0x40;ok
+ meta mark set ip6 dscp;ok
+ meta mark set ip6 dscp | 0x40;ok
++
++meta mark set ct mark and 0xffff0000 or meta mark and 0xffff;ok;meta mark set ct mark & 0xffff0000 | meta mark & 0x0000ffff
+diff --git a/tests/py/inet/meta.t.json b/tests/py/inet/meta.t.json
+index 0fee165f..4352b963 100644
+--- a/tests/py/inet/meta.t.json
++++ b/tests/py/inet/meta.t.json
+@@ -236,6 +236,43 @@
+     }
+ ]
+ 
++# meta mark set ct mark and 0xffff0000 or meta mark and 0xffff
++[
++    {
++        "mangle": {
++            "key": {
++                "meta": {
++                    "key": "mark"
++                }
++            },
++            "value": {
++                "|": [
++                    {
++                        "&": [
++                            {
++                                "ct": {
++                                    "key": "mark"
++                                }
++                            },
++                            4294901760
++                        ]
++                    },
++                    {
++                        "&": [
++                            {
++                                "meta": {
++                                    "key": "mark"
++                                }
++                            },
++                            65535
++                        ]
++                    }
++                ]
++            }
++        }
++    }
++]
++
+ # meta protocol ip udp dport 67
+ [
+     {
+diff --git a/tests/py/inet/meta.t.payload b/tests/py/inet/meta.t.payload
+index 7184fa0c..04dfbd8f 100644
+--- a/tests/py/inet/meta.t.payload
++++ b/tests/py/inet/meta.t.payload
+@@ -80,6 +80,15 @@ inet test-inet input
+   [ bitwise reg 1 = ( reg 1 >> 0x00000008 ) ]
+   [ meta set mark with reg 1 ]
+ 
++# meta mark set ct mark and 0xffff0000 or meta mark and 0xffff
++inet test-inet input
++  [ ct load mark => reg 1 ]
++  [ bitwise reg 1 = ( reg 1 & 0xffff0000 ) ^ 0x00000000 ]
++  [ meta load mark => reg 2 ]
++  [ bitwise reg 2 = ( reg 2 & 0x0000ffff ) ^ 0x00000000 ]
++  [ bitwise reg 1 = ( reg 1 | reg 2 ) ]
++  [ meta set mark with reg 1 ]
++
+ # meta protocol ip udp dport 67
+ inet test-inet input
+   [ meta load protocol => reg 1 ]
+diff --git a/tests/py/ip/ct.t b/tests/py/ip/ct.t
+index a0a22289..523d0244 100644
+--- a/tests/py/ip/ct.t
++++ b/tests/py/ip/ct.t
+@@ -28,9 +28,11 @@ meta mark set ct original saddr . meta mark map { 1.1.1.1 . 0x00000014 : 0x00000
+ meta mark set ct original ip saddr . meta mark map { 1.1.1.1 . 0x00000014 : 0x0000001e };ok
+ ct original saddr . meta mark { 1.1.1.1 . 0x00000014 };fail
+ ct original ip saddr . meta mark { 1.1.1.1 . 0x00000014 };ok
++
+ ct mark set ip dscp << 2 | 0x10;ok
+ ct mark set ip dscp << 26 | 0x10;ok
+ ct mark set ip dscp & 0x0f << 1;ok;ct mark set ip dscp & af33
+ ct mark set ip dscp & 0x0f << 2;ok;ct mark set ip dscp & 0x3c
+ ct mark set ip dscp | 0x04;ok
+ ct mark set ip dscp | 1 << 20;ok;ct mark set ip dscp | 0x100000
++ct mark set ct mark | ip dscp | 0x200 counter;ok;ct mark set ct mark | ip dscp | 0x00000200 counter
+diff --git a/tests/py/ip/ct.t.json b/tests/py/ip/ct.t.json
+index 915632ae..9e60f7e2 100644
+--- a/tests/py/ip/ct.t.json
++++ b/tests/py/ip/ct.t.json
+@@ -479,3 +479,35 @@
+         }
+     }
+ ]
++
++# ct mark set ct mark | ip dscp | 0x200 counter
++[
++    {
++        "mangle": {
++            "key": {
++                "ct": {
++                    "key": "mark"
++                }
++            },
++            "value": {
++                "|": [
++                  {
++                    "ct": {
++                      "key": "mark"
++                    }
++                  },
++                  {
++                    "payload": {
++                      "protocol": "ip",
++                      "field": "dscp"
++                    }
++                  },
++                  512
++                ]
++            }
++        }
++    },
++    {
++        "counter": null
++    }
++]
+diff --git a/tests/py/ip/ct.t.payload b/tests/py/ip/ct.t.payload
+index 692011d0..823de597 100644
+--- a/tests/py/ip/ct.t.payload
++++ b/tests/py/ip/ct.t.payload
+@@ -134,3 +134,14 @@ ip test-ip4 output
+   [ bitwise reg 1 = ( reg 1 >> 0x00000002 ) ]
+   [ bitwise reg 1 = ( reg 1 & 0xffefffff ) ^ 0x00100000 ]
+   [ ct set mark with reg 1 ]
++
++# ct mark set ct mark | ip dscp | 0x200 counter
++ip test-ip4 output
++  [ ct load mark => reg 1 ]
++  [ payload load 1b @ network header + 1 => reg 2 ]
++  [ bitwise reg 2 = ( reg 2 & 0x000000fc ) ^ 0x00000000 ]
++  [ bitwise reg 2 = ( reg 2 >> 0x00000002 ) ]
++  [ bitwise reg 1 = ( reg 1 | reg 2 ) ]
++  [ bitwise reg 1 = ( reg 1 & 0xfffffdff ) ^ 0x00000200 ]
++  [ ct set mark with reg 1 ]
++  [ counter pkts 0 bytes 0 ]
+diff --git a/tests/py/ip6/ct.t b/tests/py/ip6/ct.t
+index c06fd6a0..1617c68b 100644
+--- a/tests/py/ip6/ct.t
++++ b/tests/py/ip6/ct.t
+@@ -7,3 +7,4 @@ ct mark set ip6 dscp << 26 | 0x10;ok
+ ct mark set ip6 dscp | 0x04;ok
+ ct mark set ip6 dscp | 0xff000000;ok
+ ct mark set ip6 dscp & 0x0f << 2;ok;ct mark set ip6 dscp & 0x3c
++ct mark set ct mark | ip6 dscp | 0x200 counter;ok;ct mark set ct mark | ip6 dscp | 0x00000200 counter
+diff --git a/tests/py/ip6/ct.t.json b/tests/py/ip6/ct.t.json
+index 7d8c88bb..2633c2b9 100644
+--- a/tests/py/ip6/ct.t.json
++++ b/tests/py/ip6/ct.t.json
+@@ -291,3 +291,35 @@
+         }
+     }
+ ]
++
++# ct mark set ct mark | ip6 dscp | 0x200 counter
++[
++    {
++        "mangle": {
++            "key": {
++                "ct": {
++                    "key": "mark"
++                }
++            },
++            "value": {
++                "|": [
++                  {
++                    "ct": {
++                      "key": "mark"
++                    }
++                  },
++                  {
++                    "payload": {
++                      "protocol": "ip6",
++                      "field": "dscp"
++                    }
++                  },
++                  512
++                ]
++            }
++        }
++    },
++    {
++        "counter": null
++    }
++]
+diff --git a/tests/py/ip6/ct.t.payload b/tests/py/ip6/ct.t.payload
+index 944208f2..a7a56d4b 100644
+--- a/tests/py/ip6/ct.t.payload
++++ b/tests/py/ip6/ct.t.payload
+@@ -44,3 +44,15 @@ ip6 test-ip6 output
+   [ bitwise reg 1 = ( reg 1 >> 0x00000006 ) ]
+   [ bitwise reg 1 = ( reg 1 & 0x0000003c ) ^ 0x00000000 ]
+   [ ct set mark with reg 1 ]
++
++# ct mark set ct mark | ip6 dscp | 0x200 counter
++ip6 test-ip6 output
++  [ ct load mark => reg 1 ]
++  [ payload load 2b @ network header + 0 => reg 2 ]
++  [ bitwise reg 2 = ( reg 2 & 0x0000c00f ) ^ 0x00000000 ]
++  [ byteorder reg 2 = ntoh(reg 2, 2, 2) ]
++  [ bitwise reg 2 = ( reg 2 >> 0x00000006 ) ]
++  [ bitwise reg 1 = ( reg 1 | reg 2 ) ]
++  [ bitwise reg 1 = ( reg 1 & 0xfffffdff ) ^ 0x00000200 ]
++  [ ct set mark with reg 1 ]
++  [ counter pkts 0 bytes 0 ]
+diff --git a/tests/shell/features/bitwise_multireg.nft b/tests/shell/features/bitwise_multireg.nft
+new file mode 100644
+index 00000000..cfce5a39
+--- /dev/null
++++ b/tests/shell/features/bitwise_multireg.nft
+@@ -0,0 +1,5 @@
++table inet test {
++	chain y {
++		ct mark set ct mark | meta mark
++	}
++}
+diff --git a/tests/shell/testcases/bitwise/0040mark_binop_10 b/tests/shell/testcases/bitwise/0040mark_binop_10
+new file mode 100755
+index 00000000..f523bd73
+--- /dev/null
++++ b/tests/shell/testcases/bitwise/0040mark_binop_10
+@@ -0,0 +1,13 @@
++#!/bin/bash
++
++# NFT_TEST_REQUIRES(NFT_TEST_HAVE_bitwise_multireg)
++
++set -e
++
++RULESET="
++  add table t
++  add chain t c { type filter hook output priority filter; }
++  add rule t c ct mark set ct mark and 0xffff0000 or meta mark and 0xffff
++"
++
++$NFT -f - <<< "$RULESET"
+diff --git a/tests/shell/testcases/bitwise/0040mark_binop_11 b/tests/shell/testcases/bitwise/0040mark_binop_11
+new file mode 100755
+index 00000000..d6dfb3b8
+--- /dev/null
++++ b/tests/shell/testcases/bitwise/0040mark_binop_11
+@@ -0,0 +1,13 @@
++#!/bin/bash
++
++# NFT_TEST_REQUIRES(NFT_TEST_HAVE_bitwise_multireg)
++
++set -e
++
++RULESET="
++  add table t
++  add chain t c { type filter hook input priority filter; }
++  add rule t c meta mark set ct mark and 0xffff0000 or meta mark and 0xffff
++"
++
++$NFT -f - <<< "$RULESET"
+diff --git a/tests/shell/testcases/bitwise/0040mark_binop_12 b/tests/shell/testcases/bitwise/0040mark_binop_12
+new file mode 100755
+index 00000000..bbddb55b
+--- /dev/null
++++ b/tests/shell/testcases/bitwise/0040mark_binop_12
+@@ -0,0 +1,13 @@
++#!/bin/bash
++
++# NFT_TEST_REQUIRES(NFT_TEST_HAVE_bitwise_multireg)
++
++set -e
++
++RULESET="
++  add table ip6 t
++  add chain ip6 t c { type filter hook output priority filter; }
++  add rule ip6 t c ct mark set ct mark and 0xffff0000 or meta mark and 0xffff
++"
++
++$NFT -f - <<< "$RULESET"
+diff --git a/tests/shell/testcases/bitwise/0040mark_binop_13 b/tests/shell/testcases/bitwise/0040mark_binop_13
+new file mode 100755
+index 00000000..769acb63
+--- /dev/null
++++ b/tests/shell/testcases/bitwise/0040mark_binop_13
+@@ -0,0 +1,13 @@
++#!/bin/bash
++
++# NFT_TEST_REQUIRES(NFT_TEST_HAVE_bitwise_multireg)
++
++set -e
++
++RULESET="
++  add table ip6 t
++  add chain ip6 t c { type filter hook input priority filter; }
++  add rule ip6 t c meta mark set ct mark and 0xffff0000 or meta mark and 0xffff
++"
++
++$NFT -f - <<< "$RULESET"
+diff --git a/tests/shell/testcases/bitwise/0044payload_binop_2 b/tests/shell/testcases/bitwise/0044payload_binop_2
+new file mode 100755
+index 00000000..13c4acef
+--- /dev/null
++++ b/tests/shell/testcases/bitwise/0044payload_binop_2
+@@ -0,0 +1,13 @@
++#!/bin/bash
++
++# NFT_TEST_REQUIRES(NFT_TEST_HAVE_bitwise_multireg)
++
++set -e
++
++RULESET="
++  add table t
++  add chain t c { type filter hook output priority filter; }
++  add rule t c ct mark set ct mark | ip dscp | 0x200 counter
++"
++
++$NFT -f - <<< "$RULESET"
+diff --git a/tests/shell/testcases/bitwise/0044payload_binop_5 b/tests/shell/testcases/bitwise/0044payload_binop_5
+new file mode 100755
+index 00000000..7e8095c8
+--- /dev/null
++++ b/tests/shell/testcases/bitwise/0044payload_binop_5
+@@ -0,0 +1,13 @@
++#!/bin/bash
++
++# NFT_TEST_REQUIRES(NFT_TEST_HAVE_bitwise_multireg)
++
++set -e
++
++RULESET="
++  add table ip6 t
++  add chain ip6 t c { type filter hook output priority filter; }
++  add rule ip6 t c ct mark set ct mark | ip6 dscp | 0x200 counter
++"
++
++$NFT -f - <<< "$RULESET"
+diff --git a/tests/shell/testcases/bitwise/dumps/0040mark_binop_10.nft b/tests/shell/testcases/bitwise/dumps/0040mark_binop_10.nft
+new file mode 100644
+index 00000000..5566f729
+--- /dev/null
++++ b/tests/shell/testcases/bitwise/dumps/0040mark_binop_10.nft
+@@ -0,0 +1,6 @@
++table ip t {
++	chain c {
++		type filter hook output priority filter; policy accept;
++		ct mark set ct mark & 0xffff0000 | meta mark & 0x0000ffff
++	}
++}
+diff --git a/tests/shell/testcases/bitwise/dumps/0040mark_binop_11.nft b/tests/shell/testcases/bitwise/dumps/0040mark_binop_11.nft
+new file mode 100644
+index 00000000..719980d5
+--- /dev/null
++++ b/tests/shell/testcases/bitwise/dumps/0040mark_binop_11.nft
+@@ -0,0 +1,6 @@
++table ip t {
++	chain c {
++		type filter hook input priority filter; policy accept;
++		meta mark set ct mark & 0xffff0000 | meta mark & 0x0000ffff
++	}
++}
+diff --git a/tests/shell/testcases/bitwise/dumps/0040mark_binop_12.nft b/tests/shell/testcases/bitwise/dumps/0040mark_binop_12.nft
+new file mode 100644
+index 00000000..bd589fe5
+--- /dev/null
++++ b/tests/shell/testcases/bitwise/dumps/0040mark_binop_12.nft
+@@ -0,0 +1,6 @@
++table ip6 t {
++	chain c {
++		type filter hook output priority filter; policy accept;
++		ct mark set ct mark & 0xffff0000 | meta mark & 0x0000ffff
++	}
++}
+diff --git a/tests/shell/testcases/bitwise/dumps/0040mark_binop_13.nft b/tests/shell/testcases/bitwise/dumps/0040mark_binop_13.nft
+new file mode 100644
+index 00000000..2b046b12
+--- /dev/null
++++ b/tests/shell/testcases/bitwise/dumps/0040mark_binop_13.nft
+@@ -0,0 +1,6 @@
++table ip6 t {
++	chain c {
++		type filter hook input priority filter; policy accept;
++		meta mark set ct mark & 0xffff0000 | meta mark & 0x0000ffff
++	}
++}
+diff --git a/tests/shell/testcases/bitwise/dumps/0044payload_binop_2.nft b/tests/shell/testcases/bitwise/dumps/0044payload_binop_2.nft
+new file mode 100644
+index 00000000..ed347bb2
+--- /dev/null
++++ b/tests/shell/testcases/bitwise/dumps/0044payload_binop_2.nft
+@@ -0,0 +1,6 @@
++table ip t {
++	chain c {
++		type filter hook output priority filter; policy accept;
++		ct mark set ct mark | ip dscp | 0x00000200 counter packets 0 bytes 0
++	}
++}
+diff --git a/tests/shell/testcases/bitwise/dumps/0044payload_binop_5.nft b/tests/shell/testcases/bitwise/dumps/0044payload_binop_5.nft
+new file mode 100644
+index 00000000..ccdb93d7
+--- /dev/null
++++ b/tests/shell/testcases/bitwise/dumps/0044payload_binop_5.nft
+@@ -0,0 +1,6 @@
++table ip6 t {
++	chain c {
++		type filter hook output priority filter; policy accept;
++		ct mark set ct mark | ip6 dscp | 0x00000200 counter packets 0 bytes 0
++	}
++}
+-- 
+cgit v1.2.3
+
--- /dev/null
+++ b/target/linux/generic/backport-6.6/799-v6.13-01-netfilter-bitwise-rename-boolean-operations.patch
@@ -0,0 +1,155 @@
+From a12143e6084c502fc3cfaa8b717bffc8c14cf806 Mon Sep 17 00:00:00 2001
+From: Jeremy Sowden <jeremy@azazel.net>
+Date: Thu, 14 Nov 2024 22:07:51 +0100
+Subject: [PATCH] netfilter: bitwise: rename some boolean operation functions
+
+In the next patch we add support for doing AND, OR and XOR operations
+directly in the kernel, so rename some functions and an enum constant
+related to mask-and-xor boolean operations.
+
+Signed-off-by: Jeremy Sowden <jeremy@azazel.net>
+Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
+---
+ include/uapi/linux/netfilter/nf_tables.h | 10 ++++---
+ net/netfilter/nft_bitwise.c              | 34 ++++++++++++------------
+ 2 files changed, 24 insertions(+), 20 deletions(-)
+
+diff --git a/include/uapi/linux/netfilter/nf_tables.h b/include/uapi/linux/netfilter/nf_tables.h
+index 9e9079321380ab..487542234ccdd0 100644
+--- a/include/uapi/linux/netfilter/nf_tables.h
++++ b/include/uapi/linux/netfilter/nf_tables.h
+@@ -564,16 +564,20 @@ enum nft_immediate_attributes {
+ /**
+  * enum nft_bitwise_ops - nf_tables bitwise operations
+  *
+- * @NFT_BITWISE_BOOL: mask-and-xor operation used to implement NOT, AND, OR and
+- *                    XOR boolean operations
++ * @NFT_BITWISE_MASK_XOR: mask-and-xor operation used to implement NOT, AND, OR
++ *                        and XOR boolean operations
+  * @NFT_BITWISE_LSHIFT: left-shift operation
+  * @NFT_BITWISE_RSHIFT: right-shift operation
+  */
+ enum nft_bitwise_ops {
+-	NFT_BITWISE_BOOL,
++	NFT_BITWISE_MASK_XOR,
+ 	NFT_BITWISE_LSHIFT,
+ 	NFT_BITWISE_RSHIFT,
+ };
++/*
++ * Old name for NFT_BITWISE_MASK_XOR.  Retained for backwards-compatibility.
++ */
++#define NFT_BITWISE_BOOL NFT_BITWISE_MASK_XOR
+ 
+ /**
+  * enum nft_bitwise_attributes - nf_tables bitwise expression netlink attributes
+diff --git a/net/netfilter/nft_bitwise.c b/net/netfilter/nft_bitwise.c
+index 7de95674fd8c44..7f6a4f8005376d 100644
+--- a/net/netfilter/nft_bitwise.c
++++ b/net/netfilter/nft_bitwise.c
+@@ -25,8 +25,8 @@ struct nft_bitwise {
+ 	struct nft_data		data;
+ };
+ 
+-static void nft_bitwise_eval_bool(u32 *dst, const u32 *src,
+-				  const struct nft_bitwise *priv)
++static void nft_bitwise_eval_mask_xor(u32 *dst, const u32 *src,
++				      const struct nft_bitwise *priv)
+ {
+ 	unsigned int i;
+ 
+@@ -68,8 +68,8 @@ void nft_bitwise_eval(const struct nft_expr *expr,
+ 	u32 *dst = &regs->data[priv->dreg];
+ 
+ 	switch (priv->op) {
+-	case NFT_BITWISE_BOOL:
+-		nft_bitwise_eval_bool(dst, src, priv);
++	case NFT_BITWISE_MASK_XOR:
++		nft_bitwise_eval_mask_xor(dst, src, priv);
+ 		break;
+ 	case NFT_BITWISE_LSHIFT:
+ 		nft_bitwise_eval_lshift(dst, src, priv);
+@@ -90,8 +90,8 @@ static const struct nla_policy nft_bitwise_policy[NFTA_BITWISE_MAX + 1] = {
+ 	[NFTA_BITWISE_DATA]	= { .type = NLA_NESTED },
+ };
+ 
+-static int nft_bitwise_init_bool(struct nft_bitwise *priv,
+-				 const struct nlattr *const tb[])
++static int nft_bitwise_init_mask_xor(struct nft_bitwise *priv,
++				     const struct nlattr *const tb[])
+ {
+ 	struct nft_data_desc mask = {
+ 		.type	= NFT_DATA_VALUE,
+@@ -185,7 +185,7 @@ static int nft_bitwise_init(const struct nft_ctx *ctx,
+ 	if (tb[NFTA_BITWISE_OP]) {
+ 		priv->op = ntohl(nla_get_be32(tb[NFTA_BITWISE_OP]));
+ 		switch (priv->op) {
+-		case NFT_BITWISE_BOOL:
++		case NFT_BITWISE_MASK_XOR:
+ 		case NFT_BITWISE_LSHIFT:
+ 		case NFT_BITWISE_RSHIFT:
+ 			break;
+@@ -193,12 +193,12 @@ static int nft_bitwise_init(const struct nft_ctx *ctx,
+ 			return -EOPNOTSUPP;
+ 		}
+ 	} else {
+-		priv->op = NFT_BITWISE_BOOL;
++		priv->op = NFT_BITWISE_MASK_XOR;
+ 	}
+ 
+ 	switch(priv->op) {
+-	case NFT_BITWISE_BOOL:
+-		err = nft_bitwise_init_bool(priv, tb);
++	case NFT_BITWISE_MASK_XOR:
++		err = nft_bitwise_init_mask_xor(priv, tb);
+ 		break;
+ 	case NFT_BITWISE_LSHIFT:
+ 	case NFT_BITWISE_RSHIFT:
+@@ -209,8 +209,8 @@ static int nft_bitwise_init(const struct nft_ctx *ctx,
+ 	return err;
+ }
+ 
+-static int nft_bitwise_dump_bool(struct sk_buff *skb,
+-				 const struct nft_bitwise *priv)
++static int nft_bitwise_dump_mask_xor(struct sk_buff *skb,
++				     const struct nft_bitwise *priv)
+ {
+ 	if (nft_data_dump(skb, NFTA_BITWISE_MASK, &priv->mask,
+ 			  NFT_DATA_VALUE, priv->len) < 0)
+@@ -248,8 +248,8 @@ static int nft_bitwise_dump(struct sk_buff *skb,
+ 		return -1;
+ 
+ 	switch (priv->op) {
+-	case NFT_BITWISE_BOOL:
+-		err = nft_bitwise_dump_bool(skb, priv);
++	case NFT_BITWISE_MASK_XOR:
++		err = nft_bitwise_dump_mask_xor(skb, priv);
+ 		break;
+ 	case NFT_BITWISE_LSHIFT:
+ 	case NFT_BITWISE_RSHIFT:
+@@ -269,7 +269,7 @@ static int nft_bitwise_offload(struct nft_offload_ctx *ctx,
+ 	const struct nft_bitwise *priv = nft_expr_priv(expr);
+ 	struct nft_offload_reg *reg = &ctx->regs[priv->dreg];
+ 
+-	if (priv->op != NFT_BITWISE_BOOL)
++	if (priv->op != NFT_BITWISE_MASK_XOR)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (memcmp(&priv->xor, &zero, sizeof(priv->xor)) ||
+@@ -406,7 +406,7 @@ nft_bitwise_fast_dump(struct sk_buff *skb,
+ 		return -1;
+ 	if (nla_put_be32(skb, NFTA_BITWISE_LEN, htonl(sizeof(u32))))
+ 		return -1;
+-	if (nla_put_be32(skb, NFTA_BITWISE_OP, htonl(NFT_BITWISE_BOOL)))
++	if (nla_put_be32(skb, NFTA_BITWISE_OP, htonl(NFT_BITWISE_MASK_XOR)))
+ 		return -1;
+ 
+ 	data.data[0] = priv->mask;
+@@ -501,7 +501,7 @@ nft_bitwise_select_ops(const struct nft_ctx *ctx,
+ 		return &nft_bitwise_ops;
+ 
+ 	if (tb[NFTA_BITWISE_OP] &&
+-	    ntohl(nla_get_be32(tb[NFTA_BITWISE_OP])) != NFT_BITWISE_BOOL)
++	    ntohl(nla_get_be32(tb[NFTA_BITWISE_OP])) != NFT_BITWISE_MASK_XOR)
+ 		return &nft_bitwise_ops;
+ 
+ 	return &nft_bitwise_fast_ops;
--- /dev/null
+++ b/target/linux/generic/backport-6.6/799-v6.13-02-netfilter-bitwise-add-support-and-or-xor-directly.patch
@@ -0,0 +1,294 @@
+From b0ccf4f53d968e794a4ea579d5135cc1aaf1a53f Mon Sep 17 00:00:00 2001
+From: Jeremy Sowden <jeremy@azazel.net>
+Date: Thu, 14 Nov 2024 22:08:13 +0100
+Subject: [PATCH] netfilter: bitwise: add support for doing AND, OR and XOR
+ directly
+
+Hitherto, these operations have been converted in user space to
+mask-and-xor operations on one register and two immediate values, and it
+is the latter which have been evaluated by the kernel.  We add support
+for evaluating these operations directly in kernel space on one register
+and either an immediate value or a second register.
+
+Pablo made a few changes to the original patch:
+
+- EINVAL if NFTA_BITWISE_SREG2 is used with fast version.
+- Allow _AND,_OR,_XOR with _DATA != sizeof(u32)
+- Dump _SREG2 or _DATA with _AND,_OR,_XOR
+
+Lantis has made a mod to this patch to save backporting the updated nft_parse_register_load function
+
+Signed-off-by: Jeremy Sowden <jeremy@azazel.net>
+Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
+---
+ include/uapi/linux/netfilter/nf_tables.h |   8 ++
+ net/netfilter/nft_bitwise.c              | 134 +++++++++++++++++++++--
+ 2 files changed, 131 insertions(+), 11 deletions(-)
+
+diff --git a/include/uapi/linux/netfilter/nf_tables.h b/include/uapi/linux/netfilter/nf_tables.h
+index 487542234ccdd0..49c944e78463f3 100644
+--- a/include/uapi/linux/netfilter/nf_tables.h
++++ b/include/uapi/linux/netfilter/nf_tables.h
+@@ -568,11 +568,17 @@ enum nft_immediate_attributes {
+  *                        and XOR boolean operations
+  * @NFT_BITWISE_LSHIFT: left-shift operation
+  * @NFT_BITWISE_RSHIFT: right-shift operation
++ * @NFT_BITWISE_AND: and operation
++ * @NFT_BITWISE_OR: or operation
++ * @NFT_BITWISE_XOR: xor operation
+  */
+ enum nft_bitwise_ops {
+ 	NFT_BITWISE_MASK_XOR,
+ 	NFT_BITWISE_LSHIFT,
+ 	NFT_BITWISE_RSHIFT,
++	NFT_BITWISE_AND,
++	NFT_BITWISE_OR,
++	NFT_BITWISE_XOR,
+ };
+ /*
+  * Old name for NFT_BITWISE_MASK_XOR.  Retained for backwards-compatibility.
+@@ -590,6 +596,7 @@ enum nft_bitwise_ops {
+  * @NFTA_BITWISE_OP: type of operation (NLA_U32: nft_bitwise_ops)
+  * @NFTA_BITWISE_DATA: argument for non-boolean operations
+  *                     (NLA_NESTED: nft_data_attributes)
++ * @NFTA_BITWISE_SREG2: second source register (NLA_U32: nft_registers)
+  *
+  * The bitwise expression supports boolean and shift operations.  It implements
+  * the boolean operations by performing the following operation:
+@@ -613,6 +620,7 @@ enum nft_bitwise_attributes {
+ 	NFTA_BITWISE_XOR,
+ 	NFTA_BITWISE_OP,
+ 	NFTA_BITWISE_DATA,
++	NFTA_BITWISE_SREG2,
+ 	__NFTA_BITWISE_MAX
+ };
+ #define NFTA_BITWISE_MAX	(__NFTA_BITWISE_MAX - 1)
+diff --git a/net/netfilter/nft_bitwise.c b/net/netfilter/nft_bitwise.c
+index 7f6a4f8005376d..d550910aabec9b 100644
+--- a/net/netfilter/nft_bitwise.c
++++ b/net/netfilter/nft_bitwise.c
+@@ -17,6 +17,7 @@
+ 
+ struct nft_bitwise {
+ 	u8			sreg;
++	u8			sreg2;
+ 	u8			dreg;
+ 	enum nft_bitwise_ops	op:8;
+ 	u8			len;
+@@ -60,28 +61,72 @@ static void nft_bitwise_eval_rshift(u32 *dst, const u32 *src,
+ 	}
+ }
+ 
++static void nft_bitwise_eval_and(u32 *dst, const u32 *src, const u32 *src2,
++				 const struct nft_bitwise *priv)
++{
++	unsigned int i, n;
++
++	for (i = 0, n = DIV_ROUND_UP(priv->len, sizeof(u32)); i < n; i++)
++		dst[i] = src[i] & src2[i];
++}
++
++static void nft_bitwise_eval_or(u32 *dst, const u32 *src, const u32 *src2,
++				const struct nft_bitwise *priv)
++{
++	unsigned int i, n;
++
++	for (i = 0, n = DIV_ROUND_UP(priv->len, sizeof(u32)); i < n; i++)
++		dst[i] = src[i] | src2[i];
++}
++
++static void nft_bitwise_eval_xor(u32 *dst, const u32 *src, const u32 *src2,
++				 const struct nft_bitwise *priv)
++{
++	unsigned int i, n;
++
++	for (i = 0, n = DIV_ROUND_UP(priv->len, sizeof(u32)); i < n; i++)
++		dst[i] = src[i] ^ src2[i];
++}
++
+ void nft_bitwise_eval(const struct nft_expr *expr,
+ 		      struct nft_regs *regs, const struct nft_pktinfo *pkt)
+ {
+ 	const struct nft_bitwise *priv = nft_expr_priv(expr);
+-	const u32 *src = &regs->data[priv->sreg];
++	const u32 *src = &regs->data[priv->sreg], *src2;
+ 	u32 *dst = &regs->data[priv->dreg];
+ 
+-	switch (priv->op) {
+-	case NFT_BITWISE_MASK_XOR:
++	if (priv->op == NFT_BITWISE_MASK_XOR) {
+ 		nft_bitwise_eval_mask_xor(dst, src, priv);
+-		break;
+-	case NFT_BITWISE_LSHIFT:
++		return;
++	}
++	if (priv->op == NFT_BITWISE_LSHIFT) {
+ 		nft_bitwise_eval_lshift(dst, src, priv);
+-		break;
+-	case NFT_BITWISE_RSHIFT:
++		return;
++	}
++	if (priv->op == NFT_BITWISE_RSHIFT) {
+ 		nft_bitwise_eval_rshift(dst, src, priv);
+-		break;
++		return;
++	}
++
++	src2 = priv->sreg2 ? &regs->data[priv->sreg2] : priv->data.data;
++
++	if (priv->op == NFT_BITWISE_AND) {
++		nft_bitwise_eval_and(dst, src, src2, priv);
++		return;
++	}
++	if (priv->op == NFT_BITWISE_OR) {
++		nft_bitwise_eval_or(dst, src, src2, priv);
++		return;
++	}
++	if (priv->op == NFT_BITWISE_XOR) {
++		nft_bitwise_eval_xor(dst, src, src2, priv);
++		return;
+ 	}
+ }
+ 
+ static const struct nla_policy nft_bitwise_policy[NFTA_BITWISE_MAX + 1] = {
+ 	[NFTA_BITWISE_SREG]	= { .type = NLA_U32 },
++	[NFTA_BITWISE_SREG2]	= { .type = NLA_U32 },
+ 	[NFTA_BITWISE_DREG]	= { .type = NLA_U32 },
+ 	[NFTA_BITWISE_LEN]	= { .type = NLA_U32 },
+ 	[NFTA_BITWISE_MASK]	= { .type = NLA_NESTED },
+@@ -105,7 +150,8 @@ static int nft_bitwise_init_mask_xor(struct nft_bitwise *priv,
+ 	};
+ 	int err;
+ 
+-	if (tb[NFTA_BITWISE_DATA])
++	if (tb[NFTA_BITWISE_DATA] ||
++	    tb[NFTA_BITWISE_SREG2])
+ 		return -EINVAL;
+ 
+ 	if (!tb[NFTA_BITWISE_MASK] ||
+@@ -139,7 +185,8 @@ static int nft_bitwise_init_shift(struct nft_bitwise *priv,
+ 	int err;
+ 
+ 	if (tb[NFTA_BITWISE_MASK] ||
+-	    tb[NFTA_BITWISE_XOR])
++	    tb[NFTA_BITWISE_XOR]  ||
++	    tb[NFTA_BITWISE_SREG2])
+ 		return -EINVAL;
+ 
+ 	if (!tb[NFTA_BITWISE_DATA])
+@@ -157,6 +204,41 @@ static int nft_bitwise_init_shift(struct nft_bitwise *priv,
+ 	return 0;
+ }
+ 
++static int nft_bitwise_init_bool(const struct nft_ctx *ctx,
++				 struct nft_bitwise *priv,
++				 const struct nlattr *const tb[])
++{
++	int err;
++
++	if (tb[NFTA_BITWISE_MASK] ||
++	    tb[NFTA_BITWISE_XOR])
++		return -EINVAL;
++
++	if ((!tb[NFTA_BITWISE_DATA] && !tb[NFTA_BITWISE_SREG2]) ||
++	    (tb[NFTA_BITWISE_DATA] && tb[NFTA_BITWISE_SREG2]))
++		return -EINVAL;
++
++	if (tb[NFTA_BITWISE_DATA]) {
++		struct nft_data_desc desc = {
++			.type	= NFT_DATA_VALUE,
++			.size	= sizeof(priv->data),
++			.len	= priv->len,
++		};
++
++		err = nft_data_init(NULL, &priv->data, &desc,
++				    tb[NFTA_BITWISE_DATA]);
++		if (err < 0)
++			return err;
++	} else {
++		err = nft_parse_register_load(tb[NFTA_BITWISE_SREG2], /* Lantis modded here to save another backport */
++					      &priv->sreg2, priv->len);
++		if (err < 0)
++			return err;
++	}
++
++	return 0;
++}
++
+ static int nft_bitwise_init(const struct nft_ctx *ctx,
+ 			    const struct nft_expr *expr,
+ 			    const struct nlattr * const tb[])
+@@ -188,6 +270,9 @@ static int nft_bitwise_init(const struct nft_ctx *ctx,
+ 		case NFT_BITWISE_MASK_XOR:
+ 		case NFT_BITWISE_LSHIFT:
+ 		case NFT_BITWISE_RSHIFT:
++		case NFT_BITWISE_AND:
++		case NFT_BITWISE_OR:
++		case NFT_BITWISE_XOR:
+ 			break;
+ 		default:
+ 			return -EOPNOTSUPP;
+@@ -204,6 +289,11 @@ static int nft_bitwise_init(const struct nft_ctx *ctx,
+ 	case NFT_BITWISE_RSHIFT:
+ 		err = nft_bitwise_init_shift(priv, tb);
+ 		break;
++	case NFT_BITWISE_AND:
++	case NFT_BITWISE_OR:
++	case NFT_BITWISE_XOR:
++		err = nft_bitwise_init_bool(ctx, priv, tb);
++		break;
+ 	}
+ 
+ 	return err;
+@@ -232,6 +322,21 @@ static int nft_bitwise_dump_shift(struct sk_buff *skb,
+ 	return 0;
+ }
+ 
++static int nft_bitwise_dump_bool(struct sk_buff *skb,
++				 const struct nft_bitwise *priv)
++{
++	if (priv->sreg2) {
++		if (nft_dump_register(skb, NFTA_BITWISE_SREG2, priv->sreg2))
++			return -1;
++	} else {
++		if (nft_data_dump(skb, NFTA_BITWISE_DATA, &priv->data,
++				  NFT_DATA_VALUE, sizeof(u32)) < 0)
++			return -1;
++	}
++
++	return 0;
++}
++
+ static int nft_bitwise_dump(struct sk_buff *skb,
+ 			    const struct nft_expr *expr, bool reset)
+ {
+@@ -255,6 +360,11 @@ static int nft_bitwise_dump(struct sk_buff *skb,
+ 	case NFT_BITWISE_RSHIFT:
+ 		err = nft_bitwise_dump_shift(skb, priv);
+ 		break;
++	case NFT_BITWISE_AND:
++	case NFT_BITWISE_OR:
++	case NFT_BITWISE_XOR:
++		err = nft_bitwise_dump_bool(skb, priv);
++		break;
+ 	}
+ 
+ 	return err;
+@@ -299,6 +409,7 @@ static bool nft_bitwise_reduce(struct nft_regs_track *track,
+ 	    track->regs[priv->dreg].bitwise &&
+ 	    track->regs[priv->dreg].bitwise->ops == expr->ops &&
+ 	    priv->sreg == bitwise->sreg &&
++	    priv->sreg2 == bitwise->sreg2 &&
+ 	    priv->dreg == bitwise->dreg &&
+ 	    priv->op == bitwise->op &&
+ 	    priv->len == bitwise->len &&
+@@ -375,7 +486,8 @@ static int nft_bitwise_fast_init(const struct nft_ctx *ctx,
+ 	if (err < 0)
+ 		return err;
+ 
+-	if (tb[NFTA_BITWISE_DATA])
++	if (tb[NFTA_BITWISE_DATA] ||
++	    tb[NFTA_BITWISE_SREG2])
+ 		return -EINVAL;
+ 
+ 	if (!tb[NFTA_BITWISE_MASK] ||
